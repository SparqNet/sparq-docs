# Contracts

In a generic term, SparqNet Contracts are custom, developer made classes that directly interacts with the current State of the Blockchain, Similar to Solidity contracts, they can be used to employ any type of logic within the Network, but differently to Solidity, it doesn't have the constrains of the EVM.

On SparqNet, in order to create a contract from scratch, besides having to create the contract logic in C++, you also have to code yourself several transaction parsing methods in order to parse the arguments of a given transaction calling your contract, besides that, you also have to worry about storing your local variables in a database, for that reason and others, SparqNet is creating a Solidity to C++ transpiller.


### Solidity to C++ Transpiller

One of the main reasons to have an Solidity to C++ transpiller, besides being able to easily bring already existing Solidity developers into the SparqNet space, is to create the intermediary functions between the transaction in the State of the Blockchain and the Contract itself, if we would do it dynamically, besides being counterproductive to one of the main SparqNet philosophies (Performance), it would also introduce development barriers.

For example, The data field of a transaction of a user calling the function ```transfer(address to, uint256 value)``` of a given contract with the arguments "0x7e4aa755550152a522d9578621ea22edab204308" and "840000000000000000000" is going to be: ```0xa9059cbb0000000000000000000000007e4aa755550152a522d9578621ea22edab20430800000000000000000000000000000000000000000000002d89577d7d40200000```

Where:

- ```0xa9059cbb``` is the function functor (keccak256("transfer(address,uint256)").substr(8))
- ```0000000000000000000000007e4aa755550152a522d9578621ea22edab204308``` is the encoded address
- ```00000000000000000000000000000000000000000000002d89577d7d40200000``` is the encoded uint256

The possibility here is to simply have a ```contractManager.processTransaction(tx)``` inside the ```State::processNewBlock``` function, where all transactions that call contracts can be routed throught a single place, The thing is that between ```contractManager.processTransaction(tx)```  and ```transfer(address to, uint256 value)``` of said Contract, the arguments need to be parsed, besides the right function being called, the transpiller comes into action by not only transpilling the solidity source code, but also generating the functions needed for argument parsing and function selection.


Besides the argument and function parsing issues, as the contract is not running in a VM, the developer has to keep in mind about their local variables and store them in a DB when opening/closing the node, the Solidity to C++ Transpiler takes care of these local variables inside the contract, one of the main differences between Solidity EVM and C++ SparqNet contracts, is that by default databases are only used when opening the node (loading a past state when starting node) and closing the node (saving the current state when closing node), local variables are kept in memory, where over Solidity, every call to a local variable is a database call.

If it is needed by the developer Contract to load something from DB during execution, he has the freedom to do so, but transpilled source code will always be at the constructor/destructor of the Contract.

One of the main features of Solidity is direct contract interaction, you are able to cast an "address" to a contract, and call it, if that address contains a valid contract and if that contract matches the Interface the developer specified, it will successfully call that contract function and return it, For example:

```js
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

interface IERC20 {
    function balanceOf(address addr) external view returns (uint256);
}

contract GetERC20Balance {
    function getERC20balance(address contractAddr, address user) external view returns (uint256) {
        IERC20 tokenContract = IERC20(contractAddr);
        return tokenContract.balanceOf(user);
    }
}

```

In the above contract, EVM casts the contractAddress into a contract with the IERC20 interface, making possible the usage of the balanceOf function.

On SparqNet, as contracts are compiled directly with the blockchain itself, a class called ContractManager can be used to hold all contract classes instances in a polymorphic manner, and a reference from it be argumented to any contract (default in the base Contract class), by using polymorphism it is possible to cast pointers from a given type (a Generic Contract stored inside a unordered_map<Address,Contract> on ContractManager) to a desired contract, this is exemplified in the ```ContractManager``` topic.

The equivalent definition in C++ would be similar to:
```c++
uint256_t GetERC20Balance::getERC20Balance(const Address& address, const Address &user) {
    auto tokenContract = dynamic_cast<const ERC20&>(this->contractManager.getContract(address));
    return tokenContract.balanceOf(address);
}
```

Don't forget that GetERC20Balance::GetERC20Balance is declared as ```external view``` function in Solidity, making getERC20Balance be a ```const``` function and forcing the contract cast to be const only, as this contract function cannot change the state.

The Solidity to C++ Transpiller can be used in any type of Solidity source code as long it's compatible, but there are different "ways" a developer can use the Transpiller, a "basic" mode and a "advanced" mode.

In the basic mode, The developer only declare the functions and local variables that he is going to use, so the transpiller can create both argument encoding and database functions necessary for the structure of the contract, this is the recommended way, as you will be sticking to code the contract logic in C++.

In advanced mode, the developer can input a full Solidity contract and it will convert all the logic in the implementation C++ source code.

Of course, as the application grows and starts getting more complex, the Solidity source code and the transpilled code is not enough for the performance requirements, and here is where the freedom of C++ shines, the developer has the freedom to do whatever he wants with his contract, load directly into the state without contractManager, don't have every variable already loaded in the state, etc, as long as he is paying attention to the lines to not trip over.

Solidity Features **NOT** available on SparqNet (through transpiller)
- Interfaces¹
- Inline Assembly
- Solidity Version < 0.8
- Libraries²
- Some of Solidity global variables (such as basefee, gasleft, and others)
- Others.

¹ Interfaces are not supported, but you can include a Contract directly instead of using interfaces.
² Libraries will be implemented in the future.

The development of the Solidity to C++ project will follow simple steps, many Solidity features will be unsupported on the start while we figure out how to adapt them in a static contract manner.

It is recommended to take a look over the solidity compiler, and possibly use it's Abstract Syntax Tree. Take a look over 
 
## OpenZeppelin Libraries

As the majority of Solidity contracts uses OpenZeppelin libraries as their dependencies, SparqNet will be creating equivalents for these libraries without requiring the transpillation of the OpenZeppelin contract source code, simply link with "openzeppelin" on the import (e.g. ```  import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";```)

## Contract base Class

The Contract base Class is the class which all contracts derive from, this contract holds all the Solidity global variables besides variables common among these contract (such as contract Address), it's header should look similar to the following:

https://docs.soliditylang.org/en/v0.8.17/units-and-global-variables.html

```c++
class Contract {
    private:
        // CONTRACT VARIABLES
        const Address _contractAddress;
        const uint64_t _chainId;
        const std::unique_ptr<ContractManager>& _contractManager;

        // GLOBAL VARIABLES
        static Address _coinbase; // Current Miner Address
        static uint256_t _blockNumber; // Current Block Number
        static uint256_t _blockTimestamp; // Current Block Timestamp
    
    public:
        Contract(const Address& contractAddress, const uint64_t& chainId, std::unique_ptr<ContractManager> &contractManager) : _contractAddress(contractAddress), _chainId(chainId), _contractManager(contractManager) {};

        const Address& coinbase() { return _coinbase };
        const uint256_t& blockNumber() { return _blockNumber};
        const uint256_t blockTimestamp() { return _blockTimestamp};

        virtual void callContractWithTransaction(const Tx& transaction);
        virtual std::string ethCallContract(const std::string& calldata) const;

        friend State; // State can update the private global variables of the contracts
}
```

Attention to the callContractWithTransaction and the ethCallContract functions.
callContractWithTransaction is used by the State when calling from processNewBlock(), while ethCallContract is used by RPC to answer for eth_call, strings returned by ethCallContract are hex strings encoded with the desired function result.

## ContractManager

The ContractManager is the class that holds all the current contract instances in the State, besides being the access point for contracts to access other contracts, it's header should look similar to the following:

```c++
class ContractManager {
    private:
        std::unordered_map<Address,std::unique_ptr<Contract>> _contracts;

    public:
        ContractManager(std::unique_ptr<DBService> &dbService);

        std::unique_ptr<Contract>& getContract(Address address);
        const std::unique_ptr<const Contract>& getConstContract(Address address) const;
        void processTransaction(const Tx& transaction)
        
}
```

The contract manager will be responsible of deploying the contracts in the chain, loading them from DB when constructing and save them to DB when desconstructing.

The function processTransaction would be similar to this:

```c++

void ContractManager::processTransaction(const Tx& transaction) {
    try {
        this->_contracts[transaction.to()]->callContractWithTransaction(transaction);
    } catch (std::exception &e) {
        // Something similar to this should be implemented
        // to know why a given transaction "reverted"
        // Logs are only stored in the local node, not serialized in txs.
        transaction.logs = e.what();
    }
}

```

The constructor of ContractManager 

## Example Contract


Giving the example Solidity contract:


```sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

contract ExampleContract {
    mapping(address => uint256) values;
    function setValue(address addr, uint256 value) external {
        values[addr] = value;
        return;
    }
}

```

The transpilled code should look similar to this:

Declaration
```c++
ExampleContract.h

#include <...>
class ExampleContract : public Contract {
    private:
        std::unordered_map<Address, uint256_t> values;

        // Const-reference as they are not changed by the function.
        void setValue(const Address &addr, const uint256 &value);
    public:
        ExampleContract(const Address& contractAddress, 
                        const uint64_t& chainId, 
                        std::unique_ptr<ContractManager> &contractManager, std::unique_ptr<DBService&> db);

        void callContractWithTransaction(const Tx& transaction)

}
```

Definition
```c++
ExampleContract.cpp
#include "ExampleContract.h"

ExampleContract(const Address& contractAddress, 
                const uint64_t& chainId, 
                std::unique_ptr<ContractManager> &contractManager, std::unique_ptr<DBService&> db) :
                Contract(contractAddress, chainId, contractManager) {
                    // Read the "values" variables from DB
                    // Code generated by the transpiller from all local variables
                    // of the solidity contract, on the ExampleContract, you have values as a address => uint256 mapping
                    ...
                }

void ExampleContract::setValue(const Address &addr, const uint256 &value) {
    this->values[addr] = value;
    return
}

void ExampleContract::callContractWithTransaction(const Tx& transaction) {
    // CODE GENERATED BY THE TRANSPILLER
    // USED TO ROUTE AND DECODE TRANSACTIONS
    // THE IF USED HERE IS FOR EXAMPLE PURPOSES
    // THE GENERATED CODE WILL BE USING DIFFERENT STRING ALGORITHMS IN ORDER TO MATCH
    // FUNCTOR AND ARGUMENTS TO CONTRACT FUNCTION.
    std::string_view txData = transaction.getData(); 
    auto functor = txData.substr(0,8);
    // Keccak256("setValue(address,uint256)")
    if (functor == Utils::hexToBytes("0x48461b56")) {
        this->setValue(ABI::Decoder::decodeAddress(txData, 8), ABI::Decoder::decodeUint256(txData, 8 + 32)); 
    }
    return;
}
                       
```


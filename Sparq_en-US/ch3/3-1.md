# 3.1 - Contracts in Sparq

In general terms, contracts in Sparq are developer-created C++ classes that directly 
interact with the blockchain's current state, similar to Solidity contracts. 
They facilitate the implementation of diverse logic within the network, taking
advantage of the absence of EVM constraints since they are composed of native,
compiled code.

To create a contract from scratch, you must develop the contract logic in C++
and manually code several transaction parsing methods to interpret the arguments
of a transaction calling your contract. Additionally, managing the storage of 
your local variables in a database is required. This chapter will comprehensively 
cover creating new contracts within OrbiterSDK.

The rules explained in this chapter ensure that contracts remain compatible with 
frontend web3 tools such as MetaMask, ethers.js, and web3.js. These tools are designed
to interact with Solidity contracts and thus require a similar interface.

To call these contracts, you can replicate the function definition in Solidity and
generate the ABI using Remix or any other preferred tool. This ABI can then be used
by ethers.js/web3.js to call the contract's functions from the frontend.

## Types of Contracts

OrbiterSDK offers two types of contracts: Dynamic Contracts and Protocol Contracts.
Both contract types derive from the same base class in our source code. When 
constructing any contract, you must adhere to specific rules detailed in this 
documentation. Generally, the rules for both types include:

- Inheriting from either the BaseContract or DynamicContract class.
- Overriding the default base class destructor.
- Managing variables within the State and Database during the contract's construction and destruction.
- Registering callbacks for the contract's functions with the proper function signature (if functions are called by RPC eth_call or a Transaction).
- Ensuring the contract name when building the contract base class matches the contract's class name.
- Marking view functions (functions that do not change state) as const and returning std::string with the encoded ABI.
- Marking functions that change state and are callable by transactions with ContractManager as void and returning void.
- Taking accountability for the base class constructor (BaseContract or DynamicContract) arguments.

Dynamic Contracts, which closely resemble Solidity contracts, must follow these rules:

- Inheriting the DynamicContract class.
- Overriding the registerContractFunctions() function and calling it during the contract's construction.
- Providing two constructors: one for contract creation within ContractManager and one for loading the contract from the DB.
- Allowing creation only through a Transaction call to the ContractManager contract.
- Using Safe variables for all contract variables, which must be private.
- Permitting loops over containers such as SafeUnorderedMap but requiring consideration of how Safe containers work.
- Triggering state changes only via a transaction call to the contract function.
- Calling updateState(true) at the end of the contract's constructor.
- Initializing all SafeVariables with "this".

For Protocol Contracts, the following rules must also be followed:

- Inheriting the BaseContract class.
- Overriding the BaseContract ethCall functions to parse transaction arguments and commit to state/revert if necessary.
- Managing State changes during ethCall functions (depending on whether the call is committing or not).

The differences between Dynamic Contracts and Protocol Contracts primarily arise
from how they are created and managed within the SDK. For instance, only the 
ContractManager class (a Protocol Contract) handles Dynamic Contracts. This 
provides Dynamic Contracts with an additional layer of protection through their
Safe Variables, allowing for automatic reversion of variable changes if a 
transaction is reverted. Furthermore, the ContractManager enables the chain 
owner to create an unlimited number of these contracts.

While Dynamic Contracts feature automatic revert capabilities, they can only
process functions and be called during a block process operation. Additionally,
all dynamic contract variables are directly loaded into memory.

### The ContractManager.

The ContractManager

Protocol contracts are directly integrated into the blockchain, while dynamic
contracts are managed by the ContractManager class. Consequently, the ContractManager 
is responsible for handling all the logic related to creating and loading Dynamic
Contracts. To create a new Dynamic Contract, you must take the following steps:

- Develop new functions for handling your new contract creation.
- Modify ethCall functions to access the new functions.

Additionally, the ContractManager manages all new global variables for contracts,
such as the contract's name, address, owner, and balance.

If the function signature of any function registered within your contract matches
the one registered, the ContractManager will call it. If an error occurs, the
ContractManager will automatically revert the changes to the account state 
(if it's a payable function). The following sections will cover the steps to 
create a new DynamicContract.

Currently, OrbiterSDK provides ERC20, ERC20Wrapper, and NativeWrapper contracts.

The ContractManager has a view function called getContractList which returns 
(address[], string[]), containing the deployed contracts and their type names.

### Global Contract Variables

There are few global functions that can be used by your contract during a ethCall.

| Global Function | Description | return type |
| --------------- | ----------- |-------------|
| getContractAddress() | Returns the contract's address | Address     |
| getContractOwner() | Returns the contract's owner | Address     |
| getContractChainId() | Returns the contract's chainId | uint64_t    |
| getContractName() |  Returns the contract's name | string      |
| getOrigin() | Returns the transaction's origin | Address     |
| getCaller() | Returns the transaction's caller | Address     |
| getValue() | Returns the transaction's value | uint256_t   |
| getCommit() | Returns if the call is committing to state | bool |

Besides that, Dynamic Contracts also have access to the following global functions:

| Global Function                       | Description                  | return type |
|---------------------------------------|------------------------------|-------------|
| const getContract<T>(address)         | Returns a contract of type T | const T     |
| callContract(address, ABI, callValue) | Calls contract function      | void        |
| getBalance(address)                   | Get the current balance of an address | uint256_t |
| sendTokens(address, value)            | Send tokens to an address    | void        |

# Creating a Dynamic Contract

Let's create a simple Dynamic Contract that can be used for depositing and 
withdrawing ERC20 tokens (ERC20Wrapper).

Take the following Solidity source code as example:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract ERC20Wrapper {
    mapping (address => mapping (address => uint256)) private _tokensAndBalances;

    function getContractBalance(address token) public view returns(uint256) {
        IERC20 erc20 = IERC20(token);
        return erc20.balanceOf(address(this));
    }

    function getUserBalance(address token, address user) public view returns (uint256) {
        return _tokensAndBalances[token][user];
    }

    function withdraw(address token, uint256 value) public {
        require(_tokensAndBalances[token][msg.sender] >= value, "User doesn't have enough balance");
        IERC20 erc20 = IERC20(token);
        _tokensAndBalances[token][msg.sender] -= value;
        erc20.transfer(msg.sender, value);
    }

    function transferTo(address token, address to, uint256 value) public {
        require(_tokensAndBalances[token][msg.sender] >= value, "User doesn't have enough balance");
        IERC20 erc20 = IERC20(token);
        _tokensAndBalances[token][msg.sender] -= value;
        erc20.transfer(to, value);
    }

    function deposit(address token, uint256 value) public {
        IERC20 erc20 = IERC20(token);
        erc20.transferFrom(msg.sender, address(this), value);
        _tokensAndBalances[token][msg.sender] += value;
    }
}
```

### Creating the contract declaration.

In order to recreate this Contract, we need to firstly create the declaration
file for it, taking this solidity source code as example, we can create the
following declaration file:

```cpp
class ERC20Wrapper : public DynamicContract {
  private:
    /// ERC20 Address => UserAddress/UserBalance
    /// mapping(address => mapping(address => uint256)) internal _tokensAndBalances;
    SafeUnorderedMap<Address,std::unordered_map<Address, uint256_t, SafeHash>> _tokensAndBalances;

    void registerContractFunctions() override;

  public:

    /// Default Constructor when loading contract from DB.
    ERC20Wrapper(ContractManager::ContractManagerInterface &interface, const Address& contractAddress, const std::unique_ptr<DB> &db);

    /// Default Constructor when building a new contract
    ERC20Wrapper(ContractManager::ContractManagerInterface &interface,
                 const Address& address, const Address& creator, const uint64_t& chainId, const std::unique_ptr<DB> &db);

    ~ERC20Wrapper() override;

    /// function getContractBalance(address _token) public view returns (uint256) { return _tokensAndBalances[_token][address(this)]; }
    std::string getContractBalance(const Address& token) const;

    /// function getUserBalance(address _token, address _user) public view returns (uint256) { return _tokensAndBalances[_token][_user]; }
    std::string getUserBalance(const Address& token, const Address& user) const;

    /// function withdraw (address _token, uint256 _value) public returns (bool)
    void withdraw(const Address& token, const uint256_t& value);

    /// function transferTo(address _token, address _to, uint256 _value) public returns (bool)
    void transferTo(const Address& token, const Address& to, const uint256_t& value);

    /// function deposit(address _token, uint256 _value) public returns (bool)
    void deposit(const Address& token, const uint256_t& value);
    
};
```
See file [src/contract/erc20wrapper.h](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/erc20wrapper.h) for the full declaration file.

On this declaration, we recreated the contract's functions but also added 
a few extra functions which were explained on the previous sections, for 
example: let's take a look at the constructor, in ERC20Wrapper there are 
two constructors:

- We use SafeVariables (such as SafeUnorderedMap) to handle the contract variables
- We create two constructors
- We override the registerContractFunctions function
- We override the destructor

Now, let's look over the definition of the contract:

### Creating the contract constructor

On the previous example, we have two constructors, presented as following:

```
ERC20Wrapper(ContractManager::ContractManagerInterface &interface, const Address& contractAddress, const std::unique_ptr<DB> &db);
```
Which is being used to load a contract from the Database during ContractManager
constructor (information about it will be presented on the next section).


```cpp
ERC20Wrapper(ContractManager::ContractManagerInterface &interface, const 
Address& address, const Address& creator, const uint64_t& chainId, const
std::unique_ptr<DB> &db);```
```

Which is being used to create a new contract during a contract creating
call on ContractManager, when creating a new contract.

Let's head over their respective declaration.

```cpp
ERC20Wrapper::ERC20Wrapper(ContractManager::ContractManagerInterface &interface, const Address& contractAddress, const std::unique_ptr<DB> &db) :
    DynamicContract(interface, contractAddress, db), _tokensAndBalances(this) {
  registerContractFunctions();
  auto tokensAndBalances = this->db->getBatch(DBPrefix::contracts + this->getContractAddress().get() + "_tokensAndBalances");
  for (const auto& dbEntry : tokensAndBalances) {
    this->_tokensAndBalances[Address(dbEntry.key, true)][Address(dbEntry.value.substr(0, 20), true)] = Utils::fromBigEndian<uint256_t>(dbEntry.value.substr(20));
  }
  updateState(true);
}
```

By using this constructor, the DynamicClass constructor will load
the contract variables (such as contract address, name, etc) from
the Database, but you are required to load the variables of your
contract from the DB too, use DBPrefix::contract + this->getContractAddress()
as prefix for the database key.
This constructor is automatically called by ContractManager constructor while loading the blockchain.

```cpp
ERC20Wrapper::ERC20Wrapper(ContractManager::ContractManagerInterface &interface,
                           const Address& address, const Address& creator, const uint64_t& chainId, const std::unique_ptr<DB> &db) :
    DynamicContract(interface, "ERC20Wrapper", address, creator, chainId, db), _tokensAndBalances(this) {
  registerContractFunctions();
  updateState(true);
}
```

While this constructor is being used to create a new contract,
as there is no previous existing contract, you are required to
initialize the variables of your contract, such as the contract
name, address, which is done by the DynamicContract class.

Take notice that both constructors call the registerContractFunctions 
function, which is responsible to register the contract functions, 
registerContractFunction() will be explained on the following sections.

### Creating the contract destructor

The contract destructor is responsible to save the current information
within the contract to the Database, this is done by the following code:

```cpp
ERC20Wrapper::~ERC20Wrapper() {
  DBBatch tokensAndBalancesBatch;

  for (auto it = _tokensAndBalances.cbegin(); it != _tokensAndBalances.cend(); ++it) {
    for (auto it2 = it->second.cbegin(); it2 != it->second.cend(); ++it2) {
      std::string key = it->first.get();
      std::string value;
      value += it2->first.get();
      value += Utils::uintToBytes(it2->second);
      tokensAndBalancesBatch.puts.emplace_back(DBEntry(key, value));
    }
  }

  this->db->putBatch(tokensAndBalancesBatch, DBPrefix::contracts + this->getContractAddress().get() + "_tokensAndBalances");
  return;
}
```

See that for the prefix of the DB we use DBPrefix::contracts +
this->getContractAddress().get() + "_tokensAndBalances", this is
the same prefix that we used on the constructor to load the contract 
variables from the DB.

### Creating the contracts functions

Creating the contracts functions are straightforward, functions that are calleable by a transaction should return void, while view functions should return the string with the ABI encoded result, see the declaration of the functions:

```cpp
std::string ERC20Wrapper::getContractBalance(const Address& token) const {
  auto* ERC20Token = this->getContract<ERC20>(token);
  return ERC20Token->balanceOf(this->getContractAddress());
}

std::string ERC20Wrapper::getUserBalance(const Address& token, const Address& user) const {
  auto it = this->_tokensAndBalances.find(token);
  if (it == this->_tokensAndBalances.end()) {
    return ABI::Encoder({0}).getRaw();
  }
  auto itUser = it->second.find(user);
  if (itUser == it->second.end()) {
    return ABI::Encoder({0}).getRaw();
  }
  return ABI::Encoder({itUser->second}).getRaw();
}

void ERC20Wrapper::withdraw(const Address& token, const uint256_t& value) {
  auto it = this->_tokensAndBalances.find(token);
  if (it == this->_tokensAndBalances.end()) {
    throw std::runtime_error("Token not found");
  }
  auto itUser = it->second.find(this->getCaller());
  if (itUser == it->second.end()) {
    throw std::runtime_error("User not found");
  }
  if (itUser->second <= value) {
    throw std::runtime_error("Not enough balance");
  }

  itUser->second -= value;
  ABI::Encoder encoder({this->getCaller(), value}, "transfer(address,uint256)");
  this->callContract(token, encoder);
}

void ERC20Wrapper::transferTo(const Address& token, const Address& to, const uint256_t& value) {
  auto it = this->_tokensAndBalances.find(token);
  if (it == this->_tokensAndBalances.end()) {
    throw std::runtime_error("Token not found");
  }
  auto itUser = it->second.find(this->getCaller());
  if (itUser == it->second.end()) {
    throw std::runtime_error("User not found");
  }
  if (itUser->second <= value) {
    throw std::runtime_error("Not enough balance");
  }

  itUser->second -= value;
  ABI::Encoder encoder({to, value}, "transfer(address,uint256)");
  this->callContract(token, encoder);
}

void ERC20Wrapper::deposit(const Address& token, const uint256_t& value) {
  ABI::Encoder encoder({this->getCaller(), this->getContractAddress(), value}, "transferFrom(address,address,uint256)");
  this->callContract(token, encoder);
  this->_tokensAndBalances[token][this->getCaller()] += value;
}
```

You can see that all the view functions are now std::string() 
const functions, while the functions that are called by a transaction 
are void() non-const functions.

In order to call another contract view funtion, you can get the 
contract with the respective type, such on the getContractBalance 
function:

```cpp
std::string ERC20Wrapper::getContractBalance(const Address& token) const {
  auto* ERC20Token = this->getContract<ERC20>(token);
  return ERC20Token->balanceOf(this->getContractAddress());
}
```

We get a pointer to the contract, the getContract function is
automatically protected in the case of casting a wrong typed 
contract or calling an inexistent contract, besides that, the 
function returns a std::string with the respective ABI encoded result.

But in order to call a non-view function, you need to use the
callContract function, such on the deposit function:

```cpp
void ERC20Wrapper::deposit(const Address& token, const uint256_t& value) {
  ABI::Encoder encoder({this->getCaller(), this->getContractAddress(), value}, "transferFrom(address,address,uint256)");
  this->callContract(token, encoder);
  this->_tokensAndBalances[token][this->getCaller()] += value;
}
```

You must encode the ABI of the function you want to call, such 
on the deposit function, we are calling the transferFrom function 
of the ERC20 contract, which is encoded as ```transferFrom(address,address,uint256)``` 
and the parameters are the caller, the contract address and the value,
which is encoded as ```{this->getCaller(), this->getContractAddress(), value}```.

As this contract is consuming the ERC20 balance of another contract, 
you firstly need to approve the contract to spend the tokens, this can
be done in the same manner as Solidity.

### Overriding the registerContractFunctions function

We need to override the registerContractFunction with the proper 
functions, this is done by calling the following functions on the 
DerivedContract

```cpp
    void registerFunction(const std::string& functor, std::function<void(const ethCallInfo& tx)> f);
    void registerPayableFunction(const std::string& functor, std::function<void(const ethCallInfo& tx)> f);
    void registerViewFunction(const std::string& functor, std::function<std::string(const ethCallInfo& str)> f);
```

Each function should be used for their effective purpose, the 
registerFunction is used to register a function that is called by 
a transaction, the registerPayableFunction is used to register a
function that is called by a transaction and is payable, and the 
registerViewFunction is used to register a view/const function.

The functor argument should be the function signature as Solidity
standards, for example, the function ```getContractBalance(address token)```
is encoded in Solidity as ```keccak256("getContractBalance(address)").substr(0,4)```,
which is equal to "0x43ab265f", and the function ```getUserBalance(address token, address user)``` 
is encoded as ```keccak256("getUserBalance(address,address)").substr(0,4)```, which 
is equal to "0x6805d6ad".

The function argument should be a lambda created within the registerContractFunctions 
function, such lambda is responsible on parsing the ethCallInfo and calling the
proper function, the ethCallInfo contains the following information on each 
index (as it is a std::tuple)


| Index | Description | Type |
| ------| ----------- | ---- |
| 0 | From (where the call is coming from) | Address |
| 1 | To (where the call is going to) | Address |
| 2 | GasLimit | uint256_t | Caller gas limit (if Tx) |
| 3 | GasPrice | uint256_t | Caller gas price (if Tx) |
| 4 | Value | uint256_t | Caller value |
| 5 | Data | std::string | Caller data |

The ethCallInfo is a std::tuple, so you can access the information by using
std::get<index>(ethCallInfo), data.substr(0,4) will be the function signature 
and the remaining data will be the ABI encoded parameters.

We provide the namespace ABI (see [src/contract/abi.h](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/abi.h) for more information), 
which contains the ABI encoder and decoder, you can use the ABI::Decoder to 
decode the ABI in order to call a function.

See the following example for ERC20Wrapper:


```cpp
void ERC20Wrapper::registerContractFunctions() {
  this->registerViewFunction(Hex::toBytes("0x43ab265f"), [this](const ethCallInfo &callInfo) {
    std::vector<ABI::Types> types = { ABI::Types::address };
    ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));
    return this->getContractBalance(decoder.getData<Address>(0));
  });
  this->registerViewFunction(Hex::toBytes("0x6805d6ad"), [this](const ethCallInfo &callInfo) {
    std::vector<ABI::Types> types = { ABI::Types::address, ABI::Types::address };
    ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));
    return this->getUserBalance(decoder.getData<Address>(0), decoder.getData<Address>(1));
  });
  this->registerFunction(Hex::toBytes("0xf3fef3a3"), [this](const ethCallInfo &callInfo) {
    std::vector<ABI::Types> types = { ABI::Types::address, ABI::Types::uint256 };
    ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));
    this->withdraw(decoder.getData<Address>(0), decoder.getData<uint256_t>(1));
  });
  this->registerFunction(Hex::toBytes("0xa5f2a152"), [this](const ethCallInfo &callInfo) {
    std::vector<ABI::Types> types = { ABI::Types::address, ABI::Types::address, ABI::Types::uint256 };
    ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));
    this->transferTo(decoder.getData<Address>(0), decoder.getData<Address>(1), decoder.getData<uint256_t>(2));
  });
  this->registerFunction(Hex::toBytes("0x47e7ef24"), [this](const ethCallInfo &callInfo) {
    std::vector<ABI::Types> types = { ABI::Types::address, ABI::Types::uint256 };
    ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));
    this->deposit(decoder.getData<Address>(0), decoder.getData<uint256_t>(1));
  });
  return;
}

```

After calling the registerContractFunctions(), all the functions registered 
will be disponible for being called by a RPC eth_call or a transaction.


### Changes in the ContractManager

Now after fully defining and implementing the contract, we need to register 
it in the ContractManager, in order to do this we need to add two functions
to the ContractManager class, modify the ethCall functions and modify the
constructor.

Let's firstly implement the new two functions, both of which should be 
private within ContractManager and take a const ethCallInfo& as argument, 
these functions should be called "createNewCONTRACTNAMEContract()" and 
"validateCreateNewCONTRACTNAMEContract()" respectively, the first function
should create a new instance of the contract and the second function verify
if the call is valid, in this example, we need to open [src/contract/contractmanager.h](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/contractmanager.h) and over the ContractManager class, add the following functions:

```cpp

... Previous Source Code....
  /// function createNewERC20Contract(string memory name, string memory symbol, uint8 decimals, uint256 supply) public {}
  void validateCreateNewERC20Contract(const ethCallInfo& callInfo) const;
  
  /// Create a new ERC20Wrapper Contract.
  /// function createNewERC20WrapperContract() public {}
  void createNewERC20WrapperContract(const ethCallInfo& callInfo);
  
  /// Check if transaction can actually create a new ERC20 contract.
  void validateCreateNewERC20WrapperContract(const ethCallInfo& callInfo) const;

  /// Create a new ERC20 Native Wrapper Contract.
... Remaining Source Code...
```

And their respecitve definition in the [ContractManager.cpp](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/contractmanager.cpp) file:

```cpp
void ContractManager::createNewERC20WrapperContract(const ethCallInfo& callInfo) {
  if (this->caller != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can create new contracts");
  }
  /// Check if desired contract address already exists
  const auto derivedContractAddress = this->deriveContractAddress(callInfo);
  if (this->contracts.contains(derivedContractAddress)) {
    throw std::runtime_error("Contract already exists");
  }

  std::unique_lock lock(this->contractsMutex);
  for (const auto& [protocolContractName, protocolContractAddress] : ProtocolContractAddresses) {
    if (protocolContractAddress == derivedContractAddress) {
      throw std::runtime_error("Contract already exists");
    }
  }

  this->contracts.insert(std::make_pair(derivedContractAddress, std::make_unique<ERC20Wrapper>(this->interface,
                                                                                               derivedContractAddress,
                                                                                               this->getCaller(),
                                                                                               this->options->getChainID(),
                                                                                               this->db)));
}

void ContractManager::validateCreateNewERC20WrapperContract(const ethCallInfo& callInfo) const {
  if (this->caller != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can create new contracts");
  }
  /// Check if desired contract address already exists
  const auto derivedContractAddress = this->deriveContractAddress(callInfo);
  if (this->contracts.contains(derivedContractAddress)) {
    throw std::runtime_error("Contract already exists");
  }

  std::unique_lock lock(this->contractsMutex);
  for (const auto& [protocolContractName, protocolContractAddress] : ProtocolContractAddresses) {
    if (protocolContractAddress == derivedContractAddress) {
      throw std::runtime_error("Contract already exists");
    }
  }
}

```
Besides that, on top of the [contractManager.cpp](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/contractmanager.h) file, you must
include the file which the contract is defined, for example 
```#include "erc20wrapper.h``` if the contract is defined in the erc20wrapper.h file.

The first if enforces that only the chain creator can create 
new contracts, the second if checks if the contract already 
exists, and the third if checks if the contract address is 
already used by a protocol contract which is not registered in the ContractManager.

the validateFunction should only parse the ABI and verify if 
the parameters are correct, the create function should create
a new instance of the contract and add it to the ContractManager.

Under the ```ContractManager::ethCall(const ethCallInfo& callInfo)``` 
function you need to parse the functor of the call and call the
corresponding function, in this case, we need to add the following lines:

```cpp
    /// function createNewERC20WrapperContract() public {}
    if (functor == Hex::toBytes("0x97aa51a3")) {
      this->createNewERC20WrapperContract(callInfo);
      return;
    }
```

and
```cpp
    if (functor == Hex::toBytes("0x97aa51a3")) {
      this->validateCreateNewERC20WrapperContract(callInfo);
      return;
    }
```

for if committing or not the transaction, after the changes the function would be like this:

```cpp
void ContractManager::ethCall(const ethCallInfo& callInfo) {
  std::string functor = std::get<5>(callInfo).substr(0, 4);
  if (this->getCommit()) {
    /// function createNewERC20Contract(string memory name, string memory symbol, uint8 decimals, uint256 supply) public {}
    if (functor == Hex::toBytes("0xb74e5ed5")) {
      this->createNewERC20Contract(callInfo);
      return;
    }
    /// function createNewERC20WrapperContract() public {}
    if (functor == Hex::toBytes("0x97aa51a3")) {
      this->createNewERC20WrapperContract(callInfo);
      return;
    }
    /// function createNewERC20NativeWrapperContract(string memory name, string memory symbol, uint8 decimals) public {}
    if (functor == Hex::toBytes("0x8b0b8c4c")) {
      this->createNewERC20NativeWrapperContract(callInfo);
      return;
    }
  } else {
    if (functor == Hex::toBytes("0xb74e5ed5")) {
      this->validateCreateNewERC20Contract(callInfo);
      return;
    }
    if (functor == Hex::toBytes("0x97aa51a3")) {
      this->validateCreateNewERC20WrapperContract(callInfo);
      return;
    }
    if (functor == Hex::toBytes("0x0x8b0b8c4c")) {
      this->validateCreateNewERC20NativeWrapperContract(callInfo);
      return;
    }
  }
  throw std::runtime_error("Invalid function call");
}
```

### Conclusion

After everything is linked together within the source code,
it is needed to add your contract source and header file
into the CMakeLists.txt file, locate it under [src/contract/CMakeLists.txt](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/CMakeLists.txt) 
and add the .h and .cpp file respectively.

```cmake 
set(CONTRACT_HEADERS
    ...
    ${CMAKE_SOURCE_DIR}/src/contract/erc20wrapper.h
    ...
    )

set(CONTRACT_SOURCES
    ...
    ${CMAKE_SOURCE_DIR}/src/contract/erc20wrapper.cpp
    ...
    )
```

Once added, you can now run scripts/AIO-script.sh, setup a
local network, deploy your contract using the chain owner
private key and test your contract compatibility with your
favorite frontend tool, it is also possible to create the 
tests using the internal test framework (catch2) for more 
information see:

In order to deploy your contract, you must call the function ```createNewERC20WrapperContract()``` with a transaction to the ContractManager contract address, the function will create a new ERC20Wrapper contract and return the address of the new contract, you can then use the address to interact with the contract.
- [tests/contract/erc20wrapper.cpp](https://github.com/SparqNet/orbitersdk-cpp/blob/main/tests/contract/erc20wrapper.cpp)
- [tests/contract/nativewrapper.cpp](https://github.com/SparqNet/orbitersdk-cpp/blob/main/tests/contract/nativewrapper.cpp)
- [src/contract/nativewrapper.h](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/nativewrapper.h)
- [src/contract/nativewrapper.cpp](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/nativewrapper.cpp)
- [src/contract/erc20.h](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/erc20.h)
- [src/contract/erc20.cpp](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/erc20.cpp)


# Protocol Contracts

Protocol Contracts are contracts that are not directly linked 
to the ContractManager itself, they are classes not contained
by it, because of that, it takes out most of the restriction 
of the Dynamic Contracts, while adding some new ones.

## Creating Protocol Contracts.

Protocol Contracts, as implied are completely up to you for 
the most part and where to place the ownership of them within
the source code, we throughly recommend using doxygen to 
generate the documentation of the current source code to better
understand the structure of the project and how your contract 
can fit in, you can create any contract you want, but there are
some requirements that you need to follow:

- Adding Protocol Contract to protocolContractAddresses

Under [src/contract/contractmanager.h](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/contractmanager.h) you will find a global std::unordered_map, which contains the protocol contract addresses, you should stick to the same format as the other contracts, and add your contract address to the map.

- Attention to the State

It is required to pay attention to the State of the contract 
and how nodes will interact between each other, for example, 
if you have a contract that is doing parallel processing of a
task, you need to make sure that this task can be replicated 
with the same result in any node, not taking care of the State
of the contract will lead to undefined behavior, that means,

- Override ethCall function

It is necessary to override the ethCall function in order to
make functions calleable by a transaction or a ethCall, 
Protocol Contracts doesn't have automatic function parsing,
neither handles call revert, so you need to handle it yourself.

- Attention to this->getCommit()

When this->getCommit() == false, it means that the current 
call is trying to simulate to see if it's going to throw or 
not, but if this->getCommit() == true, it means that the
current call is trying to commit to the state, and you 
should do respectively if it doesn't throw.

- Adding a reference to the ContractManager

Nevertheless, it is needed to add a reference of your protocol 
contract to the ContractManager, this is done with the rdPoS 
contract (another protocol contract), see more under[src/contract/contractmanager.h](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/contractmanager.h) [src/contract/contractmanager.cpp](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/contractmanager.cpp) and [src/core/rdpos.h](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/core/rdpos.h) [src/core/rdpos.cpp](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/core/rdpos.cpp)



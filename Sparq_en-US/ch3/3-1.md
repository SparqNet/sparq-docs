# 3.1 - Contracts in Sparq

In general terms, contracts in Sparq are developer-created C++ classes that directly interact with the blockchain's current state, similar to Solidity contracts. They facilitate diverse logic implementations within the network, while taking advantage of the absence of EVM constraints, since they are composed of native, compiled code.

This chapter will comprehensively cover creating new contracts within OrbiterSDK.

To create a contract from scratch (assuming you have already forked the project - if not, now's the time, see [3-3](3-3.md)), you must develop the contract logic in C++, manually code several methods to parse arguments of transactions calling your contract, and use a database to manage the storage of your local variables.

The rules explained throughout this chapter ensure that contracts remain compatible with frontend Web3 tools (e.g. MetaMask, ethers.js, web3.js, etc.). Those are designed to interact with Solidity contracts and thus require a similar interface.

To call contracts, you can replicate the function definitions in Solidity and generate the ABI using a tool like Ethereum's [Remix](https://remix.ethereum.org/) or any other of your preference. This ABI can then be used by MetaMask/ethers.js/web3.js to call the contract's functions from the frontend.

## Types of Contracts

OrbiterSDK offers two types of contracts: **Dynamic Contracts** and **Protocol Contracts**. The differences between both types primarily come from how they are created and managed within the SDK.

*Dynamic Contracts*:

* Can only be handled by the `ContractManager` class (see below), which enables the chain owner to create an unlimited number of those  
* Have an additional layer of protection - *Safe Variables*, which allow a finer control on whether their changes are commited to the state or automatically reverted when necessary (e.g. a transaction is reverted)  
* Can only be called and process their functions during a block processing operation  
* Are directly loaded into memory and closely resemble Solidity contracts

*Protocol Contracts*:

* Are directly baked in/integrated into the blockchain, thus not linked to the `ContractManager` class and not contained by it, which removes some restrictions but adds others
* Are completely up to you (for the most part) as to where to place their ownership, variables and commit/revert logic within the source code of the blockchain (Safe Variables only work with Dynamic Contracts)

Dynamic Contracts are highly recommended due to their ensured safety with the use of Safe Variables. Currently, OrbiterSDK provides the following templates for Dynamic Contracts: `ERC20`, `ERC20Wrapper`, and `NativeWrapper`.

### The ContractManager class

The `ContractManager` class (declared in `src/contract/contractmanager.h`) is a *Protocol Contract*, responsible for:

* Handling all the logic related to creating and loading Dynamic Contracts
* Managing global variables for contracts, such as the contract's name, address, owner, and balance

If the signature of any function registered within your contract matches the one registered in ContractManager, it will call it. If an error occurs, it will automatically revert the changes made to the account state (in case it's a payable function).

It also has a view function called `getContractList()` which returns an `(address[], string[])` map, containing the deployed contracts and their type names.


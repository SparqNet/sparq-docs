# 3.4 - Creating a Dynamic Contract (Simple)

Let's create a simple Solidity contract that allows two private variables to be changed by the owner of the contract. We will call this contract `SimpleContract`.

## Solidity Example

We'll be using the following Solidity code as a reference:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8;

contract SimpleContract {
  address owner;
  string name;
  uint256 value;

  constructor(string memory argName, uint256 argValue) {
    owner = msg.sender;
    name = argName;
    value = argValue;
  }

  function getName() public view returns(string memory) {
    return name;
  }

  function getValue() public view returns(uint256) {
    return value;
  }

  function setName(string memory argName) public {
    require(msg.sender == owner, "Not owner");
    name = argName;
  }

  function setValue(uint256 argValue) public {
    require(msg.sender == owner, "Not owner");
    value = argValue;
  }
}
```

The contract has a pretty simple structure - a constructor that sets its owner, and two functions that allow the owner to change the `name` and `value` variables.

## Step 1 - Creating the Files

To recreate this contract as a native Sparq contract, first we need to create its header (`.h`) and source (`.cpp`) files, as is customary in C++ development - the header will have the definition of our contract class, and the source will have its implementation details.

Go to your local testnet's root folder, into the `src/contract` subfolder, and create two new files - `simplecontract.h` and `simplecontract.cpp`. Those files will contain the declaration and definition of your contract's logic, respectively.

![CreateSimpleContractFiles](img/CreateSimpleContractFiles.gif)

Then, add both files to the `CMakeLists.txt` file in the same folder, so they can be compiled with the project:

```cmake
set(CONTRACT_HEADERS
  ...
  ${CMAKE_SOURCE_DIR}/src/contract/simplecontract.h
  ...
)
set(CONTRACT_SOURCES
  ...
  ${CMAKE_SOURCE_DIR}/src/contract/simplecontract.cpp
  ...
)
```

## Step 2 - Declaring the Contract Class

Open the header file (`simplecontract.h`) and add the following lines:

```cpp
#ifndef SIMPLECONTRACT_H
#define SIMPLECONTRACT_H

#include "dynamiccontract.h"
#include "variables/safestring.h"
#include "variables/safeuint256_t.h"

class SimpleContract : public DynamicContract {
  private:
    ...
  public:
    ...
};

#endif // SIMPLECONTRACT_H
```

This is a simple skeleton so we can start building the proper contract. From top to bottom:

* We create [include guards](https://en.wikipedia.org/wiki/Include_guard) as a safety measure
* We include the `DynamicContract` class and two SafeVariable classes for the contract's inner variables - `SafeString` and `SafeUint256_t`, which represent a Solidity `string` and `uint256` type, respectively
* We create our `SimpleContract` class, inherit it from `DynamicContract`, and leave some space for the private and public members that will be coded next

### Step 2.1 - Declaring the Contract Variables and Functions

Now we can declare the variables of the contract and their respective functions in the header. We have to pay attention to some rules described earlier in [Chapter 3.2](3-2.md):

- Contract variables MUST be `private` and inherit one of the SafeVariable classes
- View functions MUST be `const` and return a `Bytes` type with ABI encoded data
- Non-view functions MUST be non-`const` and return `void`
- `registerContract()` MUST be `public static void`
- `registerContractFunctions()` MUST be `private void override`

So our class declaration would turn into something like this (Solidity equivalents are commented for reference):

```cpp
class SimpleContract : public DynamicContract {
  private:
    SafeString name;  // string name
    SafeUint256_t value; // uint256 value
    void registerContractFunctions() override;

  public:
    Bytes getName() const;  // function getName() public view returns(string memory)
    Bytes getValue() const; // function getValue() public view returns(uint256)
    void setName(const std::string& argName); // function setName(string memory argName) public
    void setValue(uint256_t argValue);  // function setValue(uint256 argValue) public

    static void registerContract() {
      ...
    }
};
```

Notice we can use normal/primitive types on setters just fine, as the contract variables themselves already ensure commit/revert safety due to their types.

### Step 2.2 - Declaring the Contract Constructor and Destructor

Like any C++ derived class, we must call its base class constructor and pass the proper arguments to it (besides the arguments for the derived class itself) so it can be constructed properly.

Any contract derived from `DynamicContract` (as is the case here) must have *two* constructors - one for loading the contract from the database, and another for creating a new contract from scratch. Our example would look like this:

```c++
// Constructor from scratch. Create new contract with given name and value.
SimpleContract(
  const std::string& name,
  uint256_t value,
  ContractManagerInterface &interface,
  const Address& address,
  const Address& creator,
  const uint64_t& chainId,
  const std::unique_ptr<DB> &db
);

// Constructor from load. Load contract from database.
SimpleContract(
  ContractManagerInterface &interface,
  const Address& address,
  const std::unique_ptr<DB> &db
);

// Destructor.
~SimpleContract() override;
```

Notice we declare our contract's inner variables as primitive arguments in the first constructor (from scratch), for the same reasons as the previous step. We must also manually declare the destructor of our own class and mark it as `override`, that way the compiler knows we are overriding the base class destructor and can properly call it. Both constructors also take a few other arguments required by the base class' constructor, as shown in `dynamiccontract.h`:

```cpp
// Constructor that loads the contract from the database
DynamicContract(
  ContractManagerInterface &interface,
  const Address& address,
  const std::unique_ptr<DB> &db
);

// Constructor that creates the contract from scratch
DynamicContract(
  const std::string& contractName,
  ContractManagerInterface &interface,
  const Address& address,
  const Address& creator,
  const uint64_t& chainId,
  const std::unique_ptr<DB> &db
);
```

`interface`, `address`, `creator`, `chainId` and `db` are internal variables used by the base class, and should *always* be declared *last*.

The contract's name (passed to the base class constructor as `contractName`) MUST be EXACTLY the same as the name of your contract class. This is because `contractName` is used to load the contract type from the database, so incorrectly naming it will result in a segfault at load time.

### Step 2.3 - Registering the Contract Class

One last thing we have to do within our header is properly register the contract class. All Dynamic Contracts use reflections/metaprogramming to automate most of the hard work for both our contract and the ContractManager class.

First, define a *public* tuple called `ConstructorArguments` with the contract's variable types from its first constructor (the one from scratch - in our example, name is `const std::string&` and value is `uint256_t`):

```cpp
#ifndef SIMPLECONTRACT_H
#define SIMPLECONTRACT_H

#include "dynamiccontract.h"
#include "variables/safestring.h"
#include "variables/safeuint256_t.h"

class SimpleContract : public DynamicContract {
  ...
  public:
    using ConstructorArguments = std::tuple<const std::string&, uint256_t>;
}
```

Then, we create a function called `registerContract()` that will register the contract class itself. The function MUST be *public,* *static*, return *void*, and call `ContractReflectionInterface::registerContract<>()`, like this:

```c++
class SimpleContract : public DynamicContract {
  public:
    static void registerContract() {
      ContractReflectionInterface::registerContract<
        SimpleContract, const std::string&, uint256_t,
        ContractManagerInterface&,
        const Address&, const Address&, const uint64_t&,
        const std::unique_ptr<DB>&
      >(
        std::vector<std::string>{"name", "value"},
        std::make_tuple("getName", &SimpleContract::getName, "view", std::vector<std::string>{}),
        std::make_tuple("getValue", &SimpleContract::getValue, "view", std::vector<std::string>{}),
        std::make_tuple("setName", &SimpleContract::setName, "nonpayable", std::vector<std::string>{"argName"}),
        std::make_tuple("setValue", &SimpleContract::setValue, "nonpayable", std::vector<std::string>{"argValue"})
      );
    }
}
```

The function simply calls `ContractReflectionInterface::registerContract<>()` and passes a bunch of arguments from the contract to it.

Inside the chevrons (`registerContract<...>()`):

* The first argument is the contract's class name (for this example, `SimpleContract`)
* The following arguments are all the *types* of arguments inside its first constructor (from scratch - the same ones that were put inside `ConstructorArguments`) - you can copy-paste the constructor's arguments as-is and take out the names

As for the arguments themselves (`registerContract<>(...)`):

* The first argument is a list of all the *exact names* of the arguments in the constructor
  * This does not include arguments used by the base class' constructor (e.g. `interface`, `address`, `creator`, `chainId`, `db`)
  * In our case it would only be `name` and `value`, as it is written *inside the constructor*
* The following arguments are tuples that contain, respectively:
  * The *exact names* of the class' methods (`"getName"`)
  * References the the class' methods (`&SimpleContract::getName`)
  * The [state mutability](https://docs.soliditylang.org/en/latest/contracts.html#state-mutability) of said methods (`"view"`, `"payable"`, `"nonpayable"` or `"pure"`)
  * A list of arguments that the methods take, if any (or a blank list if none)

It's important to note that contract arguments should be declared *before* the internal arguments used by the base class constructor.

It's also important to note that every contract MUST have both `ConstructorArguments` *and* `registerContract()` implemented in order to be registered, even if `ConstructorArguments` is empty (has no arguments in the constructor).

Finally, we go to the `customcontracts.h` file, include our contract's header and add it to the `ContractTypes` tuple, like this:

![RegisterSimpleContractClass](img/RegisterSimpleContractClass.png)

```c++
#include "erc20.h"
#include "erc20wrapper.h"
#include "nativewrapper.h"
#include "simplecontract.h" // <--- Add this line

using ContractTypes = std::tuple<ERC20, ERC20Wrapper, NativeWrapper, SimpleContract>; // <--- Add your contract here
```

### Step 2.4 - Generating the ABI

We have a tool that is compiled alongside the project that generates the ABI of your contract. To use it, go to `src/main-contract-abi.cpp` and add your contract's class name inside the chevrons in `writeContractsToJson<...>()`:

![GenerateContractABI](img/GenerateContractABI.png)

```c++
#include "contract/customcontracts.h"

int main() {
  return ContractReflectionInterface::writeContractsToJson<
    ERC20, ERC20Wrapper, NativeWrapper, SimpleContract // <--- Add your contract here
  >();
}
```

Compile the project and run `./contractabigenerator`. The outputs should be inside the `ABI` folder, as `<ClassName>.json`.

## Full Contract Header

That all said, our full example contract header should look something like this:

```cpp
#ifndef SIMPLECONTRACT_H
#define SIMPLECONTRACT_H

#include "dynamiccontract.h"
#include "variables/safestring.h"
#include "variables/safeuint256_t.h"

class SimpleContract : public DynamicContract {
  private:
    SafeString name;      // string name
    SafeUint256_t value;  // uint256 value
    void registerContractFunctions() override;

  public:
    using ConstructorArguments = std::tuple<const std::string&, uint256_t>;

    // Constructor from scratch. Create new contract with given name and value.
    SimpleContract(
      const std::string& name,
      uint256_t value,
      ContractManagerInterface &interface,
      const Address& address,
      const Address& creator,
      const uint64_t& chainId,
      const std::unique_ptr<DB> &db
    );

    // Constructor from load. Load contract from database.
    SimpleContract(
      ContractManagerInterface &interface,
      const Address& address,
      const std::unique_ptr<DB> &db
    );

    // Destructor.
    ~SimpleContract() override;

    Bytes getName() const;  // function getName() public view returns(string memory)
    Bytes getValue() const; // function getValue() public view returns(uint256)
    void setName(const std::string& argName); // function setName(string memory argName) public
    void setValue(uint256_t argValue);  // function setValue(uint256 argValue) public

    static void registerContract() {
      ContractReflectionInterface::registerContract<
        SimpleContract, const std::string&, uint256_t,
        ContractManagerInterface&,
        const Address&, const Address&, const uint64_t&,
        const std::unique_ptr<DB>&
      >(
        std::vector<std::string>{"name", "value"},
        std::make_tuple("getName", &SimpleContract::getName, "view", std::vector<std::string>{}),
        std::make_tuple("getValue", &SimpleContract::getValue, "view", std::vector<std::string>{}),
        std::make_tuple("setName", &SimpleContract::setName, "nonpayable", std::vector<std::string>{"argName"}),
        std::make_tuple("setValue", &SimpleContract::setValue, "nonpayable", std::vector<std::string>{"argValue"})
      );
    }
};

#endif // SIMPLECONTRACT_H
```

## Step 3 - Defining the Contract Class

With the header, declarations and registering done, now we can proceed to the implementation itself. Open `simplecontract.cpp` and `#include "simplecontract.h"` right at the beginning.

### Step 3.1 - Defining the Contract Constructors and Destructor

First, we need to implement the constructors and destructor of our contract class. Remember that:

* The base `DynamicContract` constructor must be called and its respective arguments must be passed in order
* Private contract variables must be accessed with `this` (e.g. `this->name`)
* The `registerContractFunctions()` and `updateState(true)` functions must be called at the end of the constructor

Our source file will look something like this:

```cpp
#include "simplecontract.h"

SimpleContract::SimpleContract(
  const std::string& name,
  uint256_t value,
  ContractManagerInterface &interface,
  const Address& address,
  const Address& creator,
  const uint64_t& chainId,
  const std::unique_ptr<DB> &db
) : DynamicContract(interface, "SimpleContract", address, creator, chainId, db), name(this), value(this) {
  this->name = name;
  this->value = value;
  registerContractFunctions();
  this->updateState(true);
}

SimpleContract::SimpleContract(
  ContractManagerInterface &interface,
  const Address& address,
  const std::unique_ptr<DB> &db
) : DynamicContract(interface, address, db), name(this), value(this) {
  this->name = Utils::bytesToString(db->get(std::string("name"), this->getDBPrefix()));
  this->value = Utils::bytesToUint256(db->get(std::string("value"), this->getDBPrefix()));
  registerContractFunctions();
  this->updateState(true);
}

SimpleContract::~SimpleContract() {
  this->db->put(std::string("name"), this->name.get(), this->getDBPrefix());
  this->db->put(std::string("value"), Utils::uint256ToBytes(this->value.get()), this->getDBPrefix());
  return;
}
```

Notice that, in the first constructor, we use `SimpleContract` as the `contractName` argument in the base `DynamicContract` constructor. As stated in Step 2.2, this match is a *requirement*, otherwise it will result in a segfault.

The destructor is responsible for saving the contract variables to the database, so that they can be loaded later by the second constructor, when `ContractManager` is being constructed. `this->getDBPrefix()` is a getter for the contract's own prefix in the database, which would be equivalent to `DBPrefix::contracts` + the contract's address.

### Step 3.2 - Defining the Contract Functions

Now, let's implement the proper functions of our contract - first, the *view* functions (that only read and never change the contract's variables when called), then, the *non-view* functions (that *do* change the contract's variables when called).

#### View functions

View functions MUST be `const` and return a `Bytes` type with ABI encoded data. In this case, the return values are the variables of the contract, so we can use the `ABI::Encoder` class to encode the variables and return the raw data. See [Chapter 3.7](3-7.md) for more details on ABI.

```cpp
Bytes SimpleContract::getName() const { return ABI::Encoder({this->name.get()}).getData(); }
Bytes SimpleContract::getValue() const { return ABI::Encoder({this->value.get()}).getData(); }
```

#### Non-view functions

Non-view functions MUST be non-`const` and return `void`. In this case, we must also check that whoever is calling those functions is the actual creator of the contract (as per the original Solidity code example at the start of the subchapter).

As said in [3.2](3-2.md), any contract has access to the global variables `caller` and `contractCreator` (via getters), which are the address of the caller of the function, and the address of the creator of the contract, respectively. So we can use those to prevent calls from unwanted addresses.

```cpp
void SimpleContract::setName(const std::string& argName) {
  if (this->getCaller() != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can call this function.");
  }
  this->name = argName;
}

void SimpleContract::setValue(uint256_t argValue) {
  if (this->getCaller() != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can call this function.");
  }
  this->value = argValue;
}
```

### Step 3.3 - Registering the Contract Functions

After all functions are coded, we must implement one more - `registerContractFunctions()`, which is responsible for registering the other functions so they can be called later by a transaction or an RPC `eth_call`.

The first thing it should do is call `registerContract()` right away, so it's guaranteed that the contract itself will be registered before its functions, like so:

```cpp
void SimpleContract::registerContractFunctions() {
  registerContract();
  ...
}
```

As for the functions themselves, you can register them in two ways: *automatic*, or *manual*. We recommend (and will focus on) the automatic approach as it requires less effort to implement, but both ways should work.

#### Automatic

Functions can be automatically registered using the reflection interface included in `DynamicContract`. Every contract deriving from it has access to the interface. The register function should look like this:

```cpp
void SimpleContract::registerContractFunctions() {
  registerContract();
  this->registerMemberFunction("getName", &SimpleContract::getName, this);
  this->registerMemberFunction("getValue", &SimpleContract::getValue, this);
  this->registerMemberFunction("setName", &SimpleContract::setName, this);
  this->registerMemberFunction("setValue", &SimpleContract::setValue, this);
}
```

All you need to do is call `this->registerMemberFunction()` for each function your contract has, always passing three arguments to it: the function's name, a reference to the function, and `this` (an instance to the contract itself). The reflection will take care of sorting out all the details.

#### Manually

If you want a finer control or a more verbose approach, functions can be manually registered using their functors/signatures, just like in Solidity, which means:

* The name of the function and types of the arguments...
* ...separated by commas and enclosed in parentheses (e.g. `func(string,uint256)`)...
* ...hashed with keccak256 (in our case, `Utils::sha3()`) and then converted to a string...
* ...taking only the first 4 bytes (8 hex characters) of the hash (also called the "functor").

This is all done by calling one of the following functions on the derived contract:

```cpp
void registerFunction(const std::string& functor, std::function<void(const ethCallInfo& tx)> f);
void registerPayableFunction(const std::string& functor, std::function<void(const ethCallInfo& tx)> f);
void registerViewFunction(const std::string& functor, std::function<std::string(const ethCallInfo& str)> f);
```

Each function should be used for their effective purpose:

* `registerFunction()` is used to register a *callable* function (a function that is called by a transaction)
* `registerPayableFunction()` is used to register a *callable* AND *payable* function
* `registerViewFunction()` is used to register a *view* function

The `functor` argument should be the function signature by Solidity standards, as in:

* `getContractBalance(address token)` -> `keccak256("getContractBalance(address)").substr(0,4)` -> `0x43ab265f`
* `getUserBalance(address token, address user)` -> `keccak256("getUserBalance(address,address)").substr(0,4)` -> `0x6805d6ad`
* And so on and so forth...

The `function` argument should be a lambda function, responsible for parsing the `ethCallInfo` argument and calling the proper function.

`ethCallInfo` is a `std::tuple` with the following information:

| Index | Description                          | Type        |
|-------|--------------------------------------|-------------|
| 0     | From (where the call is coming from) | Address     |
| 1     | To (where the call is going to)      | Address     |
| 2     | Caller Gas Limit (if Tx)             | uint256_t   |
| 3     | Caller Gas Price (if Tx)             | uint256_t   |
| 4     | Caller Value                         | uint256_t   |
| 5     | Caller Functor                       | std::string |
| 6     | Caller Data                          | std::string |

You can access each information by using `std::get<index>(ethCallInfo)`, e.g. `std::get<5>(ethCallInfo)` will get the functor, and `std::get<6>(ethCallInfo)` will get the data itself, which contains the rest of the ABI encoded parameters.

We provide an [ABI namespace](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/abi.h), which contains an encoder and decoder that you can use to encode and/or decode Solidity's ABI strings in order to call a function.

In a manual implementation, the register function would look something like this:

```cpp
void SimpleContract::registerContractFunctions() {
  this->registerViewFunction(Utils::sha3("getName()").get().substr(0,4), [this](const ethCallInfo &callInfo) {
    return this->getName();
  });
  this->registerViewFunction(Utils::sha3("getValue()").get().substr(0,4), [this](const ethCallInfo &callInfo) {
    return this->getValue();
  });
  this->registerFunction(Utils::sha3("setName(string)").get().substr(0,4), [this](const ethCallInfo &callInfo) {
    std::vector<ABI::Types> types = { ABI::Types::string };
    ABI::Decoder decoder(types, std::get<6>(callInfo));
    return this->setName(decoder.getData<std::string>(0));
  });
  this->registerFunction(Utils::sha3("setValue(uint256)").get().substr(0,4), [this](const ethCallInfo &callInfo) {
    std::vector<ABI::Types> types = { ABI::Types::uint256 };
    ABI::Decoder decoder(types, std::get<6>(callInfo));
    return this->setValue(decoder.getData<uint256_t>(0));
  });
}
```

## Full Contract Source

That all said, our full example contract source will look something like this:

```c++
#include "simplecontract.h"

SimpleContract::SimpleContract(
  const std::string& name,
  uint256_t value,
  ContractManagerInterface &interface,
  const Address& address,
  const Address& creator,
  const uint64_t& chainId,
  const std::unique_ptr<DB> &db
) : DynamicContract(interface, "SimpleContract", address, creator, chainId, db), name(this), value(this) {
  this->name = name;
  this->value = value;
  registerContractFunctions();
  this->updateState(true);
}

SimpleContract::SimpleContract(
  ContractManagerInterface &interface,
  const Address& address,
  const std::unique_ptr<DB> &db
) : DynamicContract(interface, address, db), name(this), value(this) {
  this->name = Utils::bytesToString(db->get(std::string("name"), this->getDBPrefix()));
  this->value = Utils::bytesToUint256(db->get(std::string("value"), this->getDBPrefix()));
  registerContractFunctions();
  this->updateState(true);
}

SimpleContract::~SimpleContract() {
  this->db->put(std::string("name"), this->name.get(), this->getDBPrefix());
  this->db->put(std::string("value"), Utils::uint256ToBytes(this->value.get()), this->getDBPrefix());
  return;
}

Bytes SimpleContract::getName() const { return ABI::Encoder({this->name.get()}).getData(); }

Bytes SimpleContract::getValue() const { return ABI::Encoder({this->value.get()}).getData(); }

void SimpleContract::setName(const std::string& argName) {
  if (this->getCaller() != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can call this function.");
  }
  this->name = argName;
}

void SimpleContract::setValue(uint256_t argValue) {
  if (this->getCaller() != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can call this function.");
  }
  this->value = argValue;
}

void SimpleContract::registerContractFunctions() {
  registerContract();
  this->registerMemberFunction("getName", &SimpleContract::getName, this);
  this->registerMemberFunction("getValue", &SimpleContract::getValue, this);
  this->registerMemberFunction("setName", &SimpleContract::setName, this);
  this->registerMemberFunction("setValue", &SimpleContract::setValue, this);
}
```

## Step 4 - Deploying the Blockchain

We are done! All that's left is deploying the blockchain, and to do so, we must compile and deploy it by calling `scripts/AIO-setup.sh`. See [Chapter 3.3](3-3.md) for more information.

## Step 5 (Optional) - Testing the Contract

We use the [catch2](https://github.com/catchorg/Catch2) framework to test our project as a whole, so it is possible to create an automated test using catch2 for your contract.

In order to do that, you must create a new file in `tests/contract/` with the name of your contract - in our case, `tests/contract/simplecontract.cpp`:

![CreateContractTestFile](img/CreateContractTestFile.gif)

Add the file to the `CMakeLists.txt` file in the parent folder:

![AddTestFileToCMake](img/AddTestFileToCMake.png)

```cmake
set(TESTS_SOURCES
  ...
  ${CMAKE_SOURCE_DIR}/tests/contract/simplecontract.cpp
  ...
)
```

And then copy this to `tests/contract/simplecontract.cpp`:

```cpp
#include "../../src/libs/catch2/catch_amalgamated.hpp"
#include "../../src/contract/erc20.h"
#include "../../src/contract/abi.h"
#include "../../src/utils/db.h"
#include "../../src/utils/options.h"
#include "../../src/contract/contractmanager.h"
#include "../../src/core/rdpos.h"

#include <filesystem>

// Forward Declaration.
ethCallInfoAllocated buildCallInfo(const Address& addressToCall, const Functor& function, const Bytes& dataToCall);

void initialize(
  std::unique_ptr<Options>& options,
  std::unique_ptr<DB>& db,
  std::unique_ptr<ContractManager> &contractManager,
  const std::string& dbName,
  const PrivKey& ownerPrivKey,
  const std::string& name,
  const uint256_t& value,
  bool deleteDB = true
) {
  if (deleteDB) {
    if (std::filesystem::exists(dbName)) {
      std::filesystem::remove_all(dbName);
    }
  }

  options = std::make_unique<Options>(Options::fromFile(dbName));
  db = std::make_unique<DB>(dbName);
  std::unique_ptr<rdPoS> rdpos;
  contractManager = std::make_unique<ContractManager>(nullptr, db, rdpos, options);

  if (deleteDB) {
    // Create the contract.
    ABI::Encoder::EncVar createNewSimpleContractVars;
    createNewSimpleContractVars.push_back(name);
    createNewSimpleContractVars.push_back(value);
    ABI::Encoder createNewSimpleContractEncoder(createNewSimpleContractVars);
    Bytes createNewSimpleContractData = Hex::toBytes("0x6de23252");
    Utils::appendBytes(createNewSimpleContractData, createNewSimpleContractEncoder.getData());

    TxBlock createNewSimpleContractTx = TxBlock(
      ProtocolContractAddresses.at("ContractManager"),
      Secp256k1::toAddress(Secp256k1::toUPub(ownerPrivKey)),
      createNewSimpleContractData,
      8080,
      0,
      0,
      0,
      0,
      0,
      ownerPrivKey
    );

    contractManager->callContract(createNewSimpleContractTx);
  }
}

namespace TSimpleContract {
  TEST_CASE("SimpleContract class", "[contract][simplecontract]") {
    PrivKey ownerPrivKey(Hex::toBytes("0xe89ef6409c467285bcae9f80ab1cfeb3487cfe61ab28fb7d36443e1daa0c2867"));
    Address owner = Secp256k1::toAddress(Secp256k1::toUPub(ownerPrivKey));
    SECTION("SimpleContract creation") {
      Address contractAddress;
      {
        std::unique_ptr<Options> options;
        std::unique_ptr<DB> db;
        std::unique_ptr<ContractManager> contractManager;
        initialize(options, db, contractManager, "SimpleContractCreationTest", ownerPrivKey, "TestName", 19283187581);

        // Get the contract address.
        contractAddress = contractManager->getContracts()[0].second;

        ABI::Encoder getNameEncoder({}, "getName()");
        ABI::Encoder getValueEncoder({}, "getValue()");

        Bytes nameData = contractManager->callContract(buildCallInfo(contractAddress, getNameEncoder.getFunctor(), getNameEncoder.getData()));
        Bytes valueData = contractManager->callContract(buildCallInfo(contractAddress, getValueEncoder.getFunctor(), getValueEncoder.getData()));

        ABI::Decoder nameDecoder({ABI::Types::string}, nameData);
        ABI::Decoder valueDecoder({ABI::Types::uint256}, valueData);

        REQUIRE(nameDecoder.getData<std::string>(0) == "TestName");
        REQUIRE(valueDecoder.getData<uint256_t>(0) == 19283187581);
      }

      std::unique_ptr<Options> options;
      std::unique_ptr<DB> db;
      std::unique_ptr<ContractManager> contractManager;
      initialize(options, db, contractManager, "SimpleContractCreationTest", ownerPrivKey, "TestName", 19283187581, false);

      REQUIRE(contractAddress == contractManager->getContracts()[0].second);

      ABI::Encoder getNameEncoder({}, "getName()");
      ABI::Encoder getValueEncoder({}, "getValue()");

      Bytes nameData = contractManager->callContract(buildCallInfo(contractAddress, getNameEncoder.getFunctor(), getNameEncoder.getData()));
      Bytes valueData = contractManager->callContract(buildCallInfo(contractAddress, getValueEncoder.getFunctor(), getValueEncoder.getData()));

      ABI::Decoder nameDecoder({ABI::Types::string}, nameData);
      ABI::Decoder valueDecoder({ABI::Types::uint256}, valueData);

      REQUIRE(nameDecoder.getData<std::string>(0) == "TestName");
      REQUIRE(valueDecoder.getData<uint256_t>(0) == 19283187581);
    }

    SECTION("SimpleContract setName and setValue") {
      Address contractAddress;
      {
        std::unique_ptr<Options> options;
        std::unique_ptr<DB> db;
        std::unique_ptr<ContractManager> contractManager;
        initialize(options, db, contractManager, "SimpleContractSetNameAndSetValue", ownerPrivKey, "TestName", 19283187581);

        // Get the contract address.
        contractAddress = contractManager->getContracts()[0].second;

        ABI::Encoder getNameEncoder({}, "getName()");
        ABI::Encoder getValueEncoder({}, "getValue()");

        Bytes nameData = contractManager->callContract(buildCallInfo(contractAddress, getNameEncoder.getFunctor(), getNameEncoder.getData()));
        Bytes valueData = contractManager->callContract(buildCallInfo(contractAddress, getValueEncoder.getFunctor(), getValueEncoder.getData()));

        ABI::Decoder nameDecoder({ABI::Types::string}, nameData);
        ABI::Decoder valueDecoder({ABI::Types::uint256}, valueData);

        ABI::Encoder setNameEncoder({"TryThisName"}, "setName(string)");
        ABI::Encoder setValueEncoder({uint256_t("918258172319061203818967178162134821351")}, "setValue(uint256)");

        Bytes setNameBytes;
        Utils::appendBytes(setNameBytes, setNameEncoder.getFunctor().get());
        Utils::appendBytes(setNameBytes, setNameEncoder.getData());

        Bytes setValueBytes;
        Utils::appendBytes(setValueBytes, setValueEncoder.getFunctor().get());
        Utils::appendBytes(setValueBytes, setValueEncoder.getData());

        TxBlock setNameTx(
          contractAddress,
          owner,
          setNameBytes,
          8080,
          0,
          0,
          0,
          0,
          0,
          ownerPrivKey
        );

        TxBlock setValueTx(
          contractAddress,
          owner,
          setValueBytes,
          8080,
          0,
          0,
          0,
          0,
          0,
          ownerPrivKey
        );

        contractManager->callContract(setNameTx);
        contractManager->callContract(setValueTx);

        nameData = contractManager->callContract(buildCallInfo(contractAddress, getNameEncoder.getFunctor(), getNameEncoder.getData()));
        valueData = contractManager->callContract(buildCallInfo(contractAddress, getValueEncoder.getFunctor(), getValueEncoder.getData()));

        nameDecoder = ABI::Decoder({ABI::Types::string}, nameData);
        valueDecoder = ABI::Decoder({ABI::Types::uint256}, valueData);

        REQUIRE(nameDecoder.getData<std::string>(0) == "TryThisName");
        REQUIRE(valueDecoder.getData<uint256_t>(0) == uint256_t("918258172319061203818967178162134821351"));
      }

      std::unique_ptr<Options> options;
      std::unique_ptr<DB> db;
      std::unique_ptr<ContractManager> contractManager;
      initialize(options, db, contractManager, "SimpleContractSetNameAndSetValue", ownerPrivKey, "TestName", 19283187581, false);

      REQUIRE(contractAddress == contractManager->getContracts()[0].second);

      ABI::Encoder getNameEncoder({}, "getName()");
      ABI::Encoder getValueEncoder({}, "getValue()");

      Bytes nameData = contractManager->callContract(buildCallInfo(contractAddress, getNameEncoder.getFunctor(), getNameEncoder.getData()));
      Bytes valueData = contractManager->callContract(buildCallInfo(contractAddress, getValueEncoder.getFunctor(), getValueEncoder.getData()));

      ABI::Decoder nameDecoder({ABI::Types::string}, nameData);
      ABI::Decoder valueDecoder({ABI::Types::uint256}, valueData);

      REQUIRE(nameDecoder.getData<std::string>(0) == "TryThisName");
      REQUIRE(valueDecoder.getData<uint256_t>(0) == uint256_t("918258172319061203818967178162134821351"));
    }
  }
}
```

This code is an entire test suite that checks several things within our SimpleContract example, such as:

* If the contract was properly created, by calling the `initialize()` function which will create the contract within `ContractManager` (the function mostly remains the same across all contracts, only changing the contract name, and the contract parameters)
* If our database destructor is working properly, by creating a `ContractManager` and the contract within, then unloading it, loading it again, and checking if the contract is still there
* If our functions work, by calling `ContractManager` with transactions that call said functions (where `buildCallInfo()` function is a forward declaration for usage within a view function of your contract)

Keep in mind that we're not accessing the contract directly, only interacting with it through `ContractManager`, which requires us to parse its inputs and outputs accordingly.

In order to run your tests, compile the project as you normally would (see [Chapter 3.3](3-3.md) for more information on how to set up your environment), and then run `./orbitersdkd-tests [simplecontract] -d yes` from within your build directory.

The `[simplecontract]` label forces only the tests for the contract to run (this is set in the `TEST_CASE()` lines in the example above). The `-d yes` flag makes it more verbose, showing exactly which test case is being run at the moment.

# 3.4 - Creating a Dynamic Contract (Simple)


## Solidity Example
Let's create a simple Solidity contract that allows two private variables to be changed by the owner of the contract. We will call this contract `SimpleContract`.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8;

contract SimpleContract {
    address owner;
    string name;
    uint256 value;


    constructor(string memory argName, uint256 argValue) {
        owner = msg.sender;
        name = argName;
        value = argValue;
    }

    function getName() public view returns(string memory) {
        return name;
    }

    function getValue() public view returns(uint256) {
        return value;
    }

    function setName(string memory argName) public {
        require(msg.sender == owner, "Not owner");
        name = argName;
    }

    function setValue(uint256 argValue) public {
        require(msg.sender == owner, "Not owner");
        value = argValue;
    }
}
```

## Step 1 - Creating the Files

We can see that this contract is a simple contract with a constructor that sets the owner of the contract, and two functions that allow the owner to change the name and value of the contract.

In order to recreate this contract within OrbiterSDK, we need to create the contract's header file and source file, the header file will include the definition of our contract class and the source file will include the implementation of our contract class.

Create two new files within the `src/contract/` folder, one called "simplecontract.h" and another called "simplecontract.cpp".

After creating the files, we can include then to the CMakeLists.txt file, so that they are compiled with the project, under the file `src/contract/CMakeLists.txt`, add the following lines:

```cmake
set(CONTRACT_HEADERS
  ...
  ${CMAKE_SOURCE_DIR}/src/contract/simplecontract.h
  ...
)
set(CONTRACT_SOURCES
  ...
  ${CMAKE_SOURCE_DIR}/src/contract/simplecontract.cpp
  ...
)
```

## Step 2 - Declaring the Contract Class
See the [CMakeLists.txt](https://github.com/itamarcps/orbitersdk-cpp/blob/contract-development/src/contract/CMakeLists.txt) file for the full list of files.

Now we can start to implement the contract class, open the file `src/contract/simplecontract.h` and add the following lines:

```cpp
#ifndef SIMPLECONTRACT_H
#define SIMPLECONTRACT_H

#include "dynamiccontract.h"
#include "variables/safestring.h"
#include "variables/safeuint256.h"

class SimpleContract : public DynamicContract {
  private:

  public:
    
};

#endif // SIMPLECONTRACT_H
```

### Declaring the Contract Variables

From there, we can declare the variables of the contract and their respective functions, paying attention to the Contract Rules:

Such rules are:

- Using Safe Variables for the contract variables
- view functions must be declared as const and return std::string with ABI encoded data.
- non-view functions must return void.
- registerContractFunctions() must be declared and override the base class function.

```cpp
class SimpleContract : public DynamicContract {
  private:
    // string name
    SafeString name;
    // uint256 value
    SafeUint256_t value;
    
    void registerContractFunctions() override;
  public:

    // function getName() public view returns(string memory)
    std::string getName() const;
    // function getValue() public view returns(uint256)
    std::string getValue() const;
    // function setName(string memory argName) public
    void setName(const std::string& argName);
    // function setValue(uint256 argValue) public
    void setValue(uint256_t argValue);

};
```

### Declaring the Constructor and Destructor

As within any C++ derived class, we must call the base class constructor, we only create the definition of the constructor within the header file, but we must pass the arguments for the base class besides the argument of our own class.

Any derived Dynamic Contract class must have two constructors, one for loading the contract from the database and another for creating a new contract.

There is a exception for this rule, the contractName argument MUST BE the same as the name of your contract class, this is because the contractName is used to load the contract type from the database, incorrectly naming your contracts will result in a segfault.

The constructor for DynamicContract that loads from the database is:

```cpp
DynamicContract(ContractManager::ContractManagerInterface &interface, 
                const Address& address, 
                const std::unique_ptr<DB> &db)
```

And the constructor for creating the new contract is:

```cpp
DynamicContract(ContractManager::ContractManagerInterface &interface,
                const std::string& contractName,
                const Address& address, 
                const Address& creator, 
                const uint64_t& chainId, 
                const std::unique_ptr<DB> &db)
```

We must also declare the destructor of our class, and mark it as override, so that the compiler knows that we are overriding the base class destructor and can properly call it.

Besides that, all OrbiterSDK contracts 

Taking that all to account, we can declare the constructor and destructor for our contract class:

```cpp
class SimpleContract : public DynamicContract {
  private:
    ...
  public:
    /// Create new contract with given name and value.
    SimpleContract(const std::string& name,
                   uint256_t value,
                   ContractManager::ContractManagerInterface &interface,
                   const Address& address,
                   const Address& creator,
                   const uint64_t& chainId,
                   const std::unique_ptr<DB> &db);

    /// Load contract from database.
    SimpleContract(ContractManager::ContractManagerInterface &interface,
                   const Address& address,
                   const std::unique_ptr<DB> &db);

    ~SimpleContract() override;
    ...
```

See the full declaration file [here](https://github.com/itamarcps/orbitersdk-cpp/blob/contract-development/src/contract/simplecontract.h)

## Step 3 - Defining the Contract Class

### Defining the Constructor and Destructor

Now we can proceed to the source file, open the file `src/contract/simplecontract.cpp` and start to implement the functions of our contract.

Firstly, we need to implement the constructor and destructor of our contract class, taking in mind that the DynamicContract constructor must be called with the arguments of the base class constructor and that all the variables of the contract must be initialized to (this), besides that, we must call the registerContractFunctions() function and updateState(true) functions.


```cpp
#include "simplecontract.h"

SimpleContract::SimpleContract(const std::string& name,
                               uint256_t value,
                               ContractManager::ContractManagerInterface &interface,
                               const Address& address,
                               const Address& creator,
                               const uint64_t& chainId,
                               const std::unique_ptr<DB> &db)
    : DynamicContract(interface, "SimpleContract", address, creator, chainId, db), name(this), value(this) {
  this->name = name;
  this->value = value;
  registerContractFunctions();
  this->updateState(true);
}


SimpleContract::SimpleContract(ContractManager::ContractManagerInterface &interface,
                               const Address& address,
                               const std::unique_ptr<DB> &db) : DynamicContract(interface, address, db), name(this), value(this) {
  this->name = db->get("name", DBPrefix::contracts + this->getContractAddress().get());
  this->value = Utils::bytesToUint256(db->get("value", DBPrefix::contracts + this->getContractAddress().get()));
  registerContractFunctions();
  this->updateState(true);
}

SimpleContract::~SimpleContract() {
  this->db->put("name", this->name.get(), DBPrefix::contracts + this->getContractAddress().get());
  this->db->put("value", Utils::uint256ToBytes(this->value.get()), DBPrefix::contracts + this->getContractAddress().get());
  return;
}
```

See that within the contract creation constructor, we use "SimpleContract" as the contractName argument, this is because the contractName is used to load the contract type from the database, incorrectly naming your contracts will result in a segfault.

The destructor is responsible for saving the variables of the contract to the database, so that they can be loaded later by the constructor that loads the contract from the database when ContractManager is being constructed.

We can see the full implementation of the constructor and destructor [here](https://github.com/itamarcps/orbitersdk-cpp/blob/contract-development/src/contract/simplecontract.cpp)

### Defining the Contract Functions

Now we can implement the functions of our contract, we will start with the view functions, which are the functions that only read the variables of the contract and do not change them.

```cpp
std::string SimpleContract::getName() const {
  return ABI::Encoder({this->name.get()}).getRaw();
}

std::string SimpleContract::getValue() const {
  return ABI::Encoder({this->value.get()}).getRaw();
}
```

The view functions must return a string with the ABI encoded data of the return values of the function, in this case, the return values are the variables of the contract, so we can use the ABI::Encoder class to encode the variables and return the raw data.

Now we can implement the non-view functions, which are the functions that change the variables of the contract.

```cpp
void SimpleContract::setName(const std::string& argName) {
  if(this->getCaller() != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can call this function.");
  }
  this->name = argName;
}

void SimpleContract::setValue(uint256_t argValue) {
  if(this->getCaller() != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can call this function.");
  }
  this->value = argValue;
}
```

As told, any contract within OrbiterSDK automatically has the variables `caller` and `contractCreator`, which are the address of the caller of the function and the address of the creator of the contract, respectively.

After completing the implementation of the functions of the contract, we must implement the registerContractFunctions() function, which is responsible for registering the functions of the contract to later be calleable by a transaction or a RPC eth_call.

Functions should be registered using the same Solidity function signature, that is, the name of the function and the types of the arguments, separated by commas and enclosed in parentheses, hashed (keccak256) and then converted to a string, taking only the first 4 (8 hex characters) bytes of the hash. This is done by calling the following functions on the derived contract:

```cpp
void registerFunction(const std::string& functor, std::function<void(const ethCallInfo& tx)> f);
void registerPayableFunction(const std::string& functor, std::function<void(const ethCallInfo& tx)> f);
void registerViewFunction(const std::string& functor, std::function<std::string(const ethCallInfo& str)> f);
```

Each function should be used for their effective purpose:

* `registerFunction()` is used to register a function that is called by a transaction (callable)
* `registerPayableFunction()` is used to register a function that is called by a transaction (callable) *and* is payable
* `registerViewFunction()` is used to register a view/const function

The `functor` argument should be the function signature by Solidity standards (e.g. `getContractBalance(address token)` -> `keccak256("getContractBalance(address)").substr(0,4)` -> `0x43ab265f`, `getUserBalance(address token, address user)` -> `keccak256("getUserBalance(address,address)").substr(0,4)` -> `0x6805d6ad`, etc.).

The `function` argument should be a lambda function declared on the spot, responsible for parsing `ethCallInfo` and calling the proper function. `ethCallInfo` is a `std::tuple` with the following information:

| Index | Description | Type |
| ------| ----------- | ---- |
| 0 | From (where the call is coming from) | Address |
| 1 | To (where the call is going to) | Address |
| 2 | GasLimit | uint256_t | Caller gas limit (if Tx) |
| 3 | GasPrice | uint256_t | Caller gas price (if Tx) |
| 4 | Value | uint256_t | Caller value |
| 5 | Data | std::string | Caller data |

You can access each information by using `std::get<index>(ethCallInfo)`. `data.substr(0,4)` will be the function signature and the remaining data will be the ABI encoded parameters.

We also provide the [ABI namespace](https://github.com/SparqNet/orbitersdk-cpp/blob/main/src/contract/abi.h), which contains an encoder and decoder which you can use to encode and/or decode Solidity's ABI strings in order to call a function. See the following example:

In our example

```cpp
void SimpleContract::registerContractFunctions() {
  this->registerViewFunction(Utils::sha3("getName()").get().substr(0,4), [this](const ethCallInfo &callInfo) {
    return this->getName();
  });
  this->registerViewFunction(Utils::sha3("getValue()").get().substr(0,4), [this](const ethCallInfo &callInfo) {
    return this->getValue();
  });
  this->registerFunction(Utils::sha3("setName(string)").get().substr(0,4), [this](const ethCallInfo &callInfo) {
    std::vector<ABI::Types> types = { ABI::Types::string };
    ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));
    return this->setName(decoder.getData<std::string>(0));
  });
  this->registerFunction(Utils::sha3("setValue(uint256)").get().substr(0,4), [this](const ethCallInfo &callInfo) {
    std::vector<ABI::Types> types = { ABI::Types::uint256 };
    ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));
    return this->setValue(decoder.getData<uint256_t>(0));
  });
}
```

See the full implementation of the SimpleContract class [here](https://github.com/itamarcps/orbitersdk-cpp/blob/contract-development/src/contract/simplecontract.cpp)


## Step 4 - Integrating with ContractManager.

We have successfully implemented our contract, but in order to be both deployable and callable, we must integrate it with the ContractManager class.

In order to integrate with the ContractManager class, we must do the following steps:

- Implement new functions to create and validate a transaction call to create a new contract instance.
- Modify the ContractManager constructor to load the contract from database.
- Modify the ContractManager ethCall function to call the create/validate functions.

### Implementing the Contract Creation Functions

In src/contract/contractmanager.h, we must add the following functions within the ContractManager class under private functions, taking ethCallInfo as argument:

```cpp

class ContractManager : BaseContract {
  private:
...previous source code...
    /// Create a new SimpleContract Contract
    /// function createNewSimpleContractContract(string memory name, uint256 value) public {}
    void createNewSimpleContractContract(const ethCallInfo& callInfo);
    
    /// Check if transaction can actually create a new SimpleContract contract.
    void validateCreateNewSimpleContractContract(const ethCallInfo& callInfo) const;


...remaining source code...
```

The Function signature for your createContract function should be the same as the one in Solidity, as exemplified, you can generate the ABI for your ContractManager using any web3 development tool.

See the full declaration [here](https://github.com/itamarcps/orbitersdk-cpp/blob/contract-development/src/contract/contractmanager.h)

In src/contract/contractmanager.cpp, we must add "#include "contractHeaderFile.h" and the previous declared functions, the create function should parse the argument data for contract construction, while 

```
#include "simplecontract.h"
...previous source code...
void ContractManager::createNewSimpleContractContract(const ethCallInfo& callInfo) {
  if (this->caller != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can create new contracts");
  }
  /// Check if desired contract address already exists
  const auto derivedContractAddress = this->deriveContractAddress(callInfo);
  if (this->contracts.contains(derivedContractAddress)) {
    throw std::runtime_error("Contract already exists");
  }

  std::unique_lock lock(this->contractsMutex);
  for (const auto& [protocolContractName, protocolContractAddress] : ProtocolContractAddresses) {
    if (protocolContractAddress == derivedContractAddress) {
      throw std::runtime_error("Contract already exists");
    }
  }

  /// Parse the constructor ABI
  std::vector<ABI::Types> types = { ABI::Types::string, ABI::Types::uint256 };
  ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));

  this->contracts.insert(std::make_pair(derivedContractAddress, std::make_unique<SimpleContract>(decoder.getData<std::string>(0),
                                                                                                 decoder.getData<uint256_t>(1),
                                                                                                 this->interface,
                                                                                                 derivedContractAddress,
                                                                                                 this->getCaller(),
                                                                                                 this->options->getChainID(),
                                                                                                 this->db)));
  return;
}

void ContractManager::validateCreateNewSimpleContractContract(const ethCallInfo& callInfo) const {
  if (this->caller != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can create new contracts");
  }
  /// Check if desired contract address already exists
  const auto derivedContractAddress = this->deriveContractAddress(callInfo);
  if (this->contracts.contains(derivedContractAddress)) {
    throw std::runtime_error("Contract already exists");
  }

  std::unique_lock lock(this->contractsMutex);
  for (const auto &[protocolContractName, protocolContractAddress]: ProtocolContractAddresses) {
    if (protocolContractAddress == derivedContractAddress) {
      throw std::runtime_error("Contract already exists");
    }
  }

  /// Parse the constructor ABI
  std::vector<ABI::Types> types = {ABI::Types::string, ABI::Types::uint256};
  ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));
}
...remaining source code...

```

All create Contract functions should follow the same structure, checking if the caller is the contract creator, checking if the contract already exists, and parsing the ABI to create the contract.

Besides that, we must register both functions within the ContractManager::ethCall(const ethCallInfo& callInfo) function, this function contains two if cases, one to truly commit to that function, and one that will only validate if the function doesn't throw.

We must calculate the function signature for our create function, in our case, it is keccak256("createNewSimpleContractContract(string,uint256)").substr(0,4), which is 0x6de23252.

The ethCall function should look like this:

```cpp
void ContractManager::ethCall(const ethCallInfo& callInfo) {
  std::string functor = std::get<5>(callInfo).substr(0, 4);
  if (this->getCommit()) {
    ...Other functions
    /// function createNewSimpleContract(string memory name, uint256 supply) public {}
    if (functor == Hex::toBytes("0x6de23252")) {
      this->createNewSimpleContractContract(callInfo);
      return;
    }
  } else {
    ...Other Functions
     if (functor == Hex::toBytes("0x6de23252")) {
      this->validateCreateNewSimpleContractContract(callInfo);
      return;
    }
  }
  throw std::runtime_error("Invalid function call");
}
```

Finally, modify the ContractManager constructor to include loading a contract from the database, the constructor should look like this:

```cpp
ContractManager::ContractManager(State* state, const std::unique_ptr<DB>& db, const std::unique_ptr<rdPoS>& rdpos, const std::unique_ptr<Options>& options) :
  state(state), BaseContract("ContractManager", ProtocolContractAddresses.at("ContractManager"), Address(Hex::toBytes("0x00dead00665771855a34155f5e7405489df2c3c6"), true), 0, db),
  rdpos(rdpos),
  options(options),
  interface(*this) {
  /// Load Contracts from DB.
  auto contracts = this->db->getBatch(DBPrefix::contractManager);
  for (const auto& contract : contracts) {
   ... Other Conditions
    if (contract.value == "SimpleContract") {
      Address contractAddress(contract.key, true);
      this->contracts.insert(
      std::make_pair(contractAddress, std::make_unique<SimpleContract>(this->interface, contractAddress, this->db)));
      continue;
    }

    throw std::runtime_error("Unknown contract: " + contract.value);
  }
}
```

You can see the full implementation [here](https://github.com/itamarcps/orbitersdk-cpp/blob/contract-development/src/contract/contractmanager.cpp)

## Step 5 - Deploying the Blockchain

Now that we have our contract, we can deploy the blockchain, to do so, we must first compile the code, and then run the blockchain.

You can do such by using the ```AIO-setup.sh``` script, which will compile the code and run the blockchain see [3.3 - Setting up the development environment](ch3/3-3.md) for more information.



## Step 6 (Optional) - Testing the Contract.

We use Catch2 to test our software, it is possible to create a automated test using catch2 for your contract, to do so, you must create a new file in ```tests/contracts/``` with the name of your contract, in our case, ```simplecontract.cpp```, and integrate it with the ```tests/CMakeLists.txt``` file.

Create the file ```tests/contracts/simplecontract.cpp``` with the following content:

```cpp
#include "../../src/libs/catch2/catch_amalgamated.hpp"
#include "../../src/contract/erc20.h"
#include "../../src/contract/abi.h"
#include "../../src/utils/db.h"
#include "../../src/utils/options.h"
#include "../../src/contract/contractmanager.h"
#include "../../src/core/rdpos.h"

#include <filesystem>

/// Forward Declaration.
ethCallInfo buildCallInfo(const Address& addressToCall, const std::string& dataToCall);

void initialize(std::unique_ptr<Options>& options,
                std::unique_ptr<DB>& db,
                std::unique_ptr<ContractManager> &contractManager,
                const std::string& dbName,
                const PrivKey& ownerPrivKey,
                const std::string& name,
                const uint256_t& value,
                bool deleteDB = true) {
  if (deleteDB) {
    if (std::filesystem::exists(dbName)) {
      std::filesystem::remove_all(dbName);
    }
  }

  options = std::make_unique<Options>(Options::fromFile(dbName));
  db = std::make_unique<DB>(dbName);
  std::unique_ptr<rdPoS> rdpos;
  contractManager = std::make_unique<ContractManager>(nullptr, db, rdpos, options);

  if (deleteDB) {
    /// Create the contract.
    ABI::Encoder::EncVar createNewSimpleContractVars;
    createNewSimpleContractVars.push_back(name);
    createNewSimpleContractVars.push_back(value);
    ABI::Encoder createNewSimpleContractEncoder(createNewSimpleContractVars);
    std::string createNewSimpleContractData = Hex::toBytes("0x6de23252") + createNewSimpleContractEncoder.getRaw();

    TxBlock createNewSimpleContractTx = TxBlock(
      ProtocolContractAddresses.at("ContractManager"),
      Secp256k1::toAddress(Secp256k1::toUPub(ownerPrivKey)),
      createNewSimpleContractData,
      8080,
      0,
      0,
      0,
      0,
      0,
      ownerPrivKey
    );

    contractManager->callContract(createNewSimpleContractTx);
  }
}

namespace TSimpleContract {
  TEST_CASE("Simple Contract class", "[contract][simplecontract]") {
    PrivKey ownerPrivKey(Hex::toBytes("0xe89ef6409c467285bcae9f80ab1cfeb3487cfe61ab28fb7d36443e1daa0c2867"));
    Address owner = Secp256k1::toAddress(Secp256k1::toUPub(ownerPrivKey));

  }
}

```

Add the file to the ```tests/CMakeLists.txt``` file, by adding the following line:

```cmake
set (TESTS_SOURCES
  ...
  ${CMAKE_SOURCE_DIR}/tests/contract/simplecontract.cpp
  ...
```

See [here](https://github.com/itamarcps/orbitersdk-cpp/blob/contract-development/tests/CMakeLists.txt) for the full file.

With this, we have create a simple environment to test our contract, we can now create a test to check if the contract was created, to do so, we must create a new test case, and call the ```initialize``` function, which will create the contract within the ContractManager

The buildCallInfo is a forward declaration for usage within a view function of your contract.

The initialize function mostly remains the same across all contracts, only changing the contract name, and the contract parameters.
    
In order to test contract creation, we can add the following section to our tests.

```cpp
namespace TSimpleContract {
  TEST_CASE("SimpleContract class", "[contract][simplecontract]") {
    PrivKey ownerPrivKey(Hex::toBytes("0xe89ef6409c467285bcae9f80ab1cfeb3487cfe61ab28fb7d36443e1daa0c2867"));
    Address owner = Secp256k1::toAddress(Secp256k1::toUPub(ownerPrivKey));
    SECTION("SimpleContract creation") {
      Address contractAddress;
      {
        std::unique_ptr<Options> options;
        std::unique_ptr<DB> db;
        std::unique_ptr<ContractManager> contractManager;
        initialize(options, db, contractManager, "SimpleContractCreationTest", ownerPrivKey, "TestName", 19283187581);

        /// Get the contract address.
        contractAddress = contractManager->getContracts()[0].second;

        ABI::Encoder getNameEncoder({}, "getName()");
        ABI::Encoder getValueEncoder({}, "getValue()");

        std::string nameData = contractManager->callContract(buildCallInfo(contractAddress, getNameEncoder.getRaw()));
        std::string valueData = contractManager->callContract(buildCallInfo(contractAddress, getValueEncoder.getRaw()));

        ABI::Decoder nameDecoder({ABI::Types::string}, nameData);
        ABI::Decoder valueDecoder({ABI::Types::uint256}, valueData);

        REQUIRE(nameDecoder.getData<std::string>(0) == "TestName");
        REQUIRE(valueDecoder.getData<uint256_t>(0) == 19283187581);
      }

      std::unique_ptr<Options> options;
      std::unique_ptr<DB> db;
      std::unique_ptr<ContractManager> contractManager;
      initialize(options, db, contractManager, "SimpleContractCreationTest", ownerPrivKey, "TestName", 19283187581, false);


      REQUIRE(contractAddress == contractManager->getContracts()[0].second);

      ABI::Encoder getNameEncoder({}, "getName()");
      ABI::Encoder getValueEncoder({}, "getValue()");

      std::string nameData = contractManager->callContract(buildCallInfo(contractAddress, getNameEncoder.getRaw()));
      std::string valueData = contractManager->callContract(buildCallInfo(contractAddress, getValueEncoder.getRaw()));

      ABI::Decoder nameDecoder({ABI::Types::string}, nameData);
      ABI::Decoder valueDecoder({ABI::Types::uint256}, valueData);

      REQUIRE(nameDecoder.getData<std::string>(0) == "TestName");
      REQUIRE(valueDecoder.getData<uint256_t>(0) == 19283187581);
    }
  }
}
```


It is necessary to keep in mind that we only access the ContractManager and not the contract itself, requiring us to parse inputs and outputs from the ContractManager.

This test also includes checking if our database destructor is working properly, by creating a contractManager and the contract within the manager, unloading it, and then loading it again, and checking if the contract is still there.


We can continue and test the remaining functions by calling ContractManager with a transaction.

```cpp
    SECTION("SimpleContract setName and setValue") {
      Address contractAddress;
      {
        std::unique_ptr<Options> options;
        std::unique_ptr<DB> db;
        std::unique_ptr<ContractManager> contractManager;
        initialize(options, db, contractManager, "SimpleContractSetNameAndSetValue", ownerPrivKey, "TestName", 19283187581);

        /// Get the contract address.
        contractAddress = contractManager->getContracts()[0].second;

        ABI::Encoder getNameEncoder({}, "getName()");
        ABI::Encoder getValueEncoder({}, "getValue()");

        std::string nameData = contractManager->callContract(buildCallInfo(contractAddress, getNameEncoder.getRaw()));
        std::string valueData = contractManager->callContract(buildCallInfo(contractAddress, getValueEncoder.getRaw()));

        ABI::Decoder nameDecoder({ABI::Types::string}, nameData);
        ABI::Decoder valueDecoder({ABI::Types::uint256}, valueData);

        ABI::Encoder setNameEncoder({"TryThisName"}, "setName(string)");
        ABI::Encoder setValueEncoder({uint256_t("918258172319061203818967178162134821351")}, "setValue(uint256)");

        TxBlock setNameTx(
          contractAddress,
          owner,
          setNameEncoder.getRaw(),
          8080,
          0,
          0,
          0,
          0,
          0,
          ownerPrivKey
        );

        TxBlock setValueTx(
          contractAddress,
          owner,
          setValueEncoder.getRaw(),
          8080,
          0,
          0,
          0,
          0,
          0,
          ownerPrivKey
        );

        contractManager->callContract(setNameTx);
        contractManager->callContract(setValueTx);

        nameData = contractManager->callContract(buildCallInfo(contractAddress, getNameEncoder.getRaw()));
        valueData = contractManager->callContract(buildCallInfo(contractAddress, getValueEncoder.getRaw()));

        nameDecoder = ABI::Decoder({ABI::Types::string}, nameData);
        valueDecoder = ABI::Decoder({ABI::Types::uint256}, valueData);

        REQUIRE(nameDecoder.getData<std::string>(0) == "TryThisName");
        REQUIRE(valueDecoder.getData<uint256_t>(0) == uint256_t("918258172319061203818967178162134821351"));
      }

      std::unique_ptr<Options> options;
      std::unique_ptr<DB> db;
      std::unique_ptr<ContractManager> contractManager;
      initialize(options, db, contractManager, "SimpleContractSetNameAndSetValue", ownerPrivKey, "TestName", 19283187581, false);


      REQUIRE(contractAddress == contractManager->getContracts()[0].second);

      ABI::Encoder getNameEncoder({}, "getName()");
      ABI::Encoder getValueEncoder({}, "getValue()");

      std::string nameData = contractManager->callContract(buildCallInfo(contractAddress, getNameEncoder.getRaw()));
      std::string valueData = contractManager->callContract(buildCallInfo(contractAddress, getValueEncoder.getRaw()));

      ABI::Decoder nameDecoder({ABI::Types::string}, nameData);
      ABI::Decoder valueDecoder({ABI::Types::uint256}, valueData);

      REQUIRE(nameDecoder.getData<std::string>(0) == "TryThisName");
      REQUIRE(valueDecoder.getData<uint256_t>(0) == uint256_t("918258172319061203818967178162134821351"));
    }
```

SECTIONS() should always be places within TEST_CASE scope.

In order to run your tests, you can run the following command:

```bash
## Enter the build directory.
cd build_local_testnet
## Build
make -j8
## Run the tests.
./orbitersdkd-tests [simplecontract] -d yes
```

You can find the full declaration for the test file [here](https://github.com/itamarcps/orbitersdk-cpp/blob/contract-development/tests/contract/simplecontract.cpp)
Please refer to section [3.3 - Setting up the development environment](ch3/3-3.md) for more information on how to setup your development environment.
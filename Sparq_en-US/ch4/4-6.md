# 4.6 - Contracts and ContractManager

Before diving into this chapter, it is recommended to read the enitrety of **Chapter 3 - Contracts**.

Contracts within OrbiterSDK differ significantly from those in EVM blockchains. While we provide the same functionality as Solidity with Dynamic Contracts, Protocol Contracts break away from the "rules" of VM contracts, allowing more flexibility and power.

Protocol Contracts can be designed to process information beyond transaction calls, communicate with other nodes, access files within the current system, and even automatically call themselves when certain conditions are met. As a developer, you have the freedom to create any type of contract you want, as long as you don't compromise your own blockchain (more on that later).

In OrbiterSDK, contract access within a transaction (e.g., when processing a new block) or through RPC `eth_call`/`eth_estimateGas` methods is managed by `ContractManager`, which is a Protocol Contract that is automatically created when the blockchain is initiated. It is responsible for managing transaction/RPC access to all contracts within the blockchain, as well as the creation and object ownership of Dynamic Contracts.

`ContractManager` does not own or create any Protocol Contracts. Instead, they are created during blockchain initialization, and a reference to each of them is stored within the class, allowing it to access them directly.

Furthermore, `DynamicContract` must use a special type (`SafeBase`) to properly revert changes made to the contract in case of a throw. More on this will be discussed later in the chapter.

## The ContractGlobals Class

Every contract within OrbiterSDK indirectly inherits from the `ContractGlobals` class. This class provides contracts with global variables accessible through transaction/RPC calls, and these variables are set by the [State](4-4.md) when calling the contract. The class does not have specific constructors or destructors.

| Function | Description                                        | return type |
| --------------- |----------------------------------------------------|-------------|
| getCoinbase() | Returns the block creator                          | Address     |
| getBlockHeight() | Returns the current block height                   | Address     |
| getBlockTimestamp() | Returns the current block timestamp (microseconds) | uint64_t    |
## The ContractLocals Class

Every contract within OrbiterSDK indirectly inherits from the `ContractLocals` class. This class provides contracts with local variables accessible through transaction/RPC calls, and these variables are set by `ContractManager` when calling the contract. The class does not have specific constructors or destructors.

| Global Function | Description | return type |
| --------------- | ----------- |-------------|
| getOrigin() | Returns the transaction's origin | Address     |
| getCaller() | Returns the transaction's caller | Address     |
| getValue() | Returns the transaction's value | uint256_t   |
| getCommit() | Returns if the call is committing to state | bool |
## The BaseContract Class

Every contract within OrbiterSDK indirectly inherits from the `BaseContract` class. This class not only provides the contract with a few functions, but also stores the respective contract information in the database, allowing it to be properly loaded when needed.

| Global Function | Description | return type |
| --------------- | ----------- |-------------|
| getContractAddress() | Returns the contract's address | Address     |
| getContractOwner() | Returns the contract's owner | Address     |
| getContractChainId() | Returns the contract's chainId | uint64_t    |
| getContractName() |  Returns the contract's name | string      |
Address, owner, chain ID and name are stored in the database following the prefix: `DBPrefix::contracts + contractAddress + variable name`.

`BaseContract` has two constructors: one for creating a new contract from scratch, and another for loading a contract from the database.

Protocol Contracts are only initialized when the blockchain is created, so only the "create from scratch" constructor is used. There is no need to use the "load from database" constructor, as the `BaseContract` variables of the contract will always remain the same, whereas `DynamicContract` can be either created or loaded from the database.

The `contractName` variable represents the string equivalent of the respective contract name, such as "ERC20" or "ERC721".

## DynamicContract and SafeBase

`DynamicContract` is a contract that automatically provides protection against reverts in the case of a throw within a specific function call. In C++, when you call a function that changes a variable and then throws an exception later, the changed variable will not be reverted. Consider the following example:

```c++
MyClass::updateValueAndThrow(const uint64_t key, const uint64_t value) {
  this->myMap[key] = value;
  throw std::runtime_error("Error");
}
```

If you call `updateValueAndThrow` even inside a try/catch block, the value of `myMap[key]` will be changed, but the exception will be thrown. However, this is not the case with `DynamicContract`, as it automatically revert changes made to the contract due to its built-in protection mechanisms.

This functionality is achieved by using variables that inherit from the `SafeBase` class (which we call "SafeVariables"). A `SafeBase` variable adheres to the following rules:

* A `SafeBase` variable has two T variables: one for the original value and another for a pointer to a temporary value
* A `SafeBase` variable must override the `check()`, `commit()`, and `revert()` functions
* check() should verify if the temporary value is nullptr; if it is, it should set the temporary value to the original value
* `commit()` should copy the temporary value to the original value
* `revert()` should set the temporary value to nullptr
* All `SafeBase` variables must be declared as *private* in the contract's header file and initialized with `this` as the parameter. This enables the `SafeBase` variable to mark itself as used in the `ContractManager`, allowing proper reversion of changes made to the contract
* All `SafeBase` functions must call `check()` and return the temporary value (or reference to the temporary value)
* All non-`const` `SafeBase` variables must call `markAsUsed()` when accessed, allowing the `DynamicContract` to properly register the variable as used within the function call, and properly revert or commit changes made to the contract accordingly

`DynamicContract` includes a vector of references to `SafeBase` variables, which is used to register used variables within a specific function call (more on this later).

`SafeBase` containers have some exceptions to these rules. Copying the entire container would be prohibitively expensive, so only accessed values are copied to the temporary container. This means containers do not behave like regular containers, requiring developers to exercise caution when using iterators or looping through the container.

The limitations on fully accessing iterators stem from the fact that the container is not copied in its entirety; only accessed values are copied. `SafeBase` variables that are containers must be aware of these constraints.

We have provided a `SafeUnorderedMap` variable that allows limited looping through the container. This limitation is due to the inability to access both the original and temporary containers simultaneously; you can only access one at a time. It is recommended to loop through a container within a `const` function, as this will not modify the temporary container.

Our `SafeUnorderedMap` variable includes the following functions for looping through both containers:

| Function | Description                                                          | return type    |
| --------------- |----------------------------------------------------------------------|----------------|
| cbegin() | Returns a const iterator to the beginning of the original container  | const_iterator |
| cend() | Returns a const iterator to the end of the original container        | const_iterator |
| begin() | Returns a const iterator to the beginning of the temporary container | iterator       |
| end() | Returns a const iterator to the end of the temporary container       | iterator |
| empty() | Returns true both the original and temporary container is empty      | bool |
| size() | Returns the size of the original container                           | size_type |
| tempSize() | Returns the size of the temporary container                         | size_type |
Keep in mind that the temporary and original containers are not the same, so duplicates within `size()` and `tempSize()` are possible.

## DynamicContract function registration and calling

We provide three different function types for `DynamicContract`: 
*non-payable*, *payable*, and *view* functions. Non-payable and payable functions must be non-`const` and return `void`, while view functions must be `const` and return a `std::string` with the respective ABI-encoded value.

For example, an ERC20 `transfer` function could be defined as:

```cpp
void ERC20::transfer(const Address& to, const uint256_t& value) {
  this->balances[this->getCaller()] -= value;
  this->balances[to] += value;
}
```

And an ERC20 `balanceOf` function could be defined as:

```cpp
std::string ERC20::balanceOf(const Address& owner) const {
  const auto& it = std::as_const(this->balances).find(owner);
  if (it == this->balances.end()) {
    return ABI::Encoder({0}).getRaw();
  } else {
    return ABI::Encoder({it->second}).getRaw();
  }
}
```

The `DynamicContract` class must register functions that are callable by a transaction or an RPC request by overriding the `registerContractFunctions()` method and calling it during the constructor. In order to do that, it provides three different functions for registering functions, one for each type:

| Function | Description                                                          |
| --------------- |----------------------------------------------------------------------|
| registerFunction(const std::string& functor, std::function<void(const ethCallInfo& tx)> f) | Registers a non-payable function |
| registerPayableFunction(const std::string& functor, std::function<void(const ethCallInfo& tx)> f) | Registers a payable function |
| registerViewFunction(const std::string& functor, std::function<std::string(const ethCallInfo& str)> f) | Registers a view function |
The `functor` argument should follow Solidity function signature conventions. For example, an ERC20 `transfer` function would be registered as `keccak256(transfer(address,uint256)).substr(0,4)`.

The `f` argument is a lambda function that will be called when the function is called. The `ethCallInfo` argument that it takes is a tuple containing the following information:

| Index | Description | Type |
| ------| ----------- | ---- |
| 0 | From (where the call is coming from) | Address |
| 1 | To (where the call is going to) | Address |
| 2 | GasLimit | uint256_t | Caller gas limit (if Tx) |
| 3 | GasPrice | uint256_t | Caller gas price (if Tx) |
| 4 | Value | uint256_t | Caller value |
| 5 | Data | std::string | Caller data |

The lambda function is responsible for both parsing the function arguments and calling it. For example, an ERC20 `transfer` function would be registered as:

```cpp
this->registerFunction(Hex::toBytes("0xa9059cbb"), [this](const ethCallInfo &callInfo) {
  std::vector<ABI::Types> types = { ABI::Types::address, ABI::Types::uint256 };
  ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));
  this->transfer(decoder.getData<Address>(0), decoder.getData<uint256_t>(1));
});
```

When registering a function, the `DynamicContract` class will store the respective signature and function in an `std::unordered_map`, allowing a given transaction to call any function within that contract.

Function registration is done to wrap the function call within a try/catch block, allowing a given transaction to call any function within that contract while protecting the `SafeBase` variables against any exceptions thrown by the function.

We provide two access functions for calling a function - `ethCall()` and `ethCallView()`:

```cpp
void ethCall(const ethCallInfo& callInfo) override {
  try {
    std::string funcName = std::get<5>(callInfo).substr(0, 4);
    if (this->isPayableFunction(funcName)) {
      auto func = this->payableFunctions.find(funcName);
      if (func == this->payableFunctions.end()) {
        throw std::runtime_error("Functor not found");
      }
      func->second(callInfo);
    } else {
      auto func = this->functions.find(funcName);
      if (func == this->functions.end()) {
        throw std::runtime_error("Functor not found");
      }
      func->second(callInfo);
    }
  } catch (const std::exception& e) {
    updateState(false);
    throw std::runtime_error(e.what());
  }
  updateState(this->getCommit());
};

const std::string ethCallView(const ethCallInfo& data) const override {
  try {
    std::string funcName = std::get<5>(data).substr(0, 4);
    auto func = this->viewFunctions.find(funcName);
    if (func == this->viewFunctions.end()) {
      throw std::runtime_error("Functor not found");
    }
    return func->second(data);
  } catch (std::exception &e) {
    throw std::runtime_error(e.what());
  }
}
```

You can see that within the `ethCall()` function, we call the respective function based on the data within that call. Additionally, we call `updateState(bool)` depending on the result of the function call and whether it is a simulation or not. The `updateState()` function will iterate through the marked `SafeBase` variables and call `commit()` or `revert()` accordingly, depending on the boolean argument that was passed to it.

## The ContractManager class

The `ContractManager` class is responsible for managing access to all contracts and the ownership of Dynamic Contracts within the blockchain. It is in charge of creating new instances of Dynamic Contracts and providing an interface for the [State](4-4.md) (Transactions) and HTTP (JSON RPC).

`ContractManager` is a Protocol contract, meaning that it is baked in the blockchain itself and created during its initialization. It is responsible for loading all the registered `DynamicContract` instances and managing their ownership, among other tasks.

## Accessing Contracts through ContractManager

`ContractManager` offers three types of access to the contract instances within the blockchain: one that takes transactions as inputs (for State when processing blocks), one that takes a fully constructed `ethCallInfo` to simulate a transaction (for RPC to answer `eth_estimateGas` to let the user know if the transaction is going to revert or not), and one that takes an `eth_call` request as an input. The definition for transactions is as follows:

```cpp
void ContractManager::callContract(const TxBlock& tx) {
  this->commit = true;
  if (tx.getTo() == this->getContractAddress()) {
    this->caller = tx.getFrom();
    this->origin = tx.getFrom();
    this->value = tx.getValue();
    try {
      this->ethCall(tx.txToCallInfo());
    } catch (std::exception &e) {
      this->commit = false;
      balances.clear();
      throw std::runtime_error(e.what());
    }
    this->commit = false;
    balances.clear();
    return;
  }

  if (tx.getTo() == ProtocolContractAddresses.at("rdPoS")) {
    rdpos->caller = tx.getFrom();
    rdpos->origin = tx.getFrom();
    rdpos->value = tx.getValue();
    rdpos->commit = this->commit;
    try {
      rdpos->ethCall(tx.txToCallInfo());
    } catch (std::exception &e) {
      rdpos->commit = false;
      balances.clear();
      throw std::runtime_error(e.what());
    }
    rdpos->commit = false;
    balances.clear();
    return;
  }

  std::unique_lock lock(this->contractsMutex);
  if (!this->contracts.contains(tx.getTo())) {
    balances.clear();
    throw std::runtime_error("Contract does not exist");
  }

  const auto& contract = contracts.at(tx.getTo());
  contract->caller = tx.getFrom();
  contract->origin = tx.getFrom();
  contract->value = tx.getValue();
  contract->commit = true;
  try {
    contract->ethCall(tx.txToCallInfo());
  } catch (std::exception &e) {
    contract->commit = false;
    balances.clear();
    throw std::runtime_error(e.what());
  }

  if (contract->isPayableFunction(tx.getData().substr(0, 4))) {
    this->state->processContractPayable(this->balances);
  }

  balances.clear();
  contract->commit = false;
}

```

As noted, all Protocol Contracts must be *manually* handled by `ContractManager`. This is because Protocol Contracts are not registered as Dynamic Contracts are, but rather as a class within the `ContractManager`. This is done because Protocol Contracts are not created by the chain owner calling `ContractManager`, but rather by the blockchain itself when it's compiled.

You can see that the `ContractManager` will set the `ContractLocal` variables (`caller`, `origin`, `value`, and `commit`) and call the `ethCall()` function of the contract. `commit` will let the contract know if this is a simulation or not. After that, it will check if the function called was a payable function, and if it was, it will call `processContractPayable()` from State, which will update the balances of the accounts accordingly to the operations performed. Be aware that this state-related access by all contracts is protected (more on that in later sections).

The `ethCall()` function of the `ContractManager` is as follows:

```cpp
const std::string ContractManager::callContract(const ethCallInfo& callInfo) const {
  const auto& [from, to, gasLimit, gasPrice, value, data] = callInfo;
  if (to == this->getContractAddress()) {
    return this->ethCallView(callInfo);
  }

  if (to == ProtocolContractAddresses.at("rdPoS")) {
    return rdpos->ethCallView(callInfo);
  }

  std::shared_lock lock(this->contractsMutex);
  if (!this->contracts.contains(to)) {
    throw std::runtime_error("Contract does not exist");
  }
  return this->contracts.at(to)->ethCallView(callInfo);
}
```

As noted, it will call the `ethCallView()` function of the respective contract, which will return a string with the respective ABI encoding of that function.

The `ethCallView()` function of the `ContractManager` is as follows:

```cpp
bool ContractManager::validateCallContractWithTx(const ethCallInfo& callInfo) {
  const auto& [from, to, gasLimit, gasPrice, value, data] = callInfo;
  try {
    if (this->getValue()) {
      /// Payable, we need to "add" the balance to the contract
      this->interface.populateBalance(to);
      this->balances[to] += value;
    }
    if (to == this->getContractAddress()) {
      this->caller = from;
      this->origin = from;
      this->value = value;
      this->ethCall(callInfo);
      balances.clear();
      return true;
    }

    if (to == ProtocolContractAddresses.at("rdPoS")) {
      rdpos->caller = from;
      rdpos->origin = from;
      rdpos->value = value;
      rdpos->commit = false;
      rdpos->ethCall(callInfo);
      balances.clear();
      return true;
    }

    std::shared_lock lock(this->contractsMutex);
    if (!this->contracts.contains(to)) {
      balances.clear();
      return false;
    }
    const auto &contract = contracts.at(to);
    contract->caller = from;
    contract->origin = from;
    contract->value = value;
    contract->commit = false;
    contract->ethCall(callInfo);
  } catch (std::exception &e) {
    balances.clear();
    throw std::runtime_error(e.what());
  }
  return true;
}
```

As observed, the `ethCall()` function of the respective contract is called, similar to `callContract()`. However, the `commit` variable is not set to `true`. This is done because this function is used to simulate transactions, and we do not want to commit the changes to the state, but rather just simulate them. This function is used by the RPC to answer `eth_estimateGas` requests.

## Registering DynamicContract within ContractManager

`ContractManager` stores all `DynamicContract`instances within a `std::unordered_map<Address,std::unique_ptr<DynamicContract>>`. This ensures that each contract has a unique address (which is derived using a similar scheme as EVM). `ContractManager` doesn't necessarily know the type of the contract stored within the pointer; it only needs to know the contract during either loading the contract from the database or during creation. For this reason, all contracts inherit the `BaseContract` class, which contains a variable `name_` specifying the name of the contract. This name must be the same as the name of the class, and it is used to identify the contract during loading and creation. The `ContractManager` will use the name to call the constructor of the contract, which will return a pointer to the contract, which will be stored within this map.

For example, the constructor of `ContractManager` does the following operation:

```cpp
  /// Load Contracts from DB.
auto contracts = this->db->getBatch(DBPrefix::contractManager);
for (const auto& contract : contracts) {
  if (contract.value == "ERC20") {
    Address contractAddress(contract.key, true);
    this->contracts.insert(std::make_pair(contractAddress, std::make_unique<ERC20>(this->interface, contractAddress, this->db)));
    continue;
  }
  if (contract.value == "ERC20Wrapper") {
    Address contractAddress(contract.key, true);
    this->contracts.insert(
    std::make_pair(contractAddress, std::make_unique<ERC20Wrapper>(this->interface, contractAddress, this->db)));
    continue;
  }
  if (contract.value == "NativeWrapper") {
    Address contractAddress(contract.key, true);
    this->contracts.insert(
    std::make_pair(contractAddress, std::make_unique<NativeWrapper>(this->interface, contractAddress, this->db)));
    continue;
  }

  throw std::runtime_error("Unknown contract: " + contract.value);
}
```

This uses the contract constructor, which loads from the DB. The destructor of `ContractManager` does not need to do anything because all DB operations related to the contract (either loading or saving) are delegated to either the inherited class (`BaseContract` for `address`, `creator`, `chainId`, etc.) or the contract itself (for the inner variables of that contract).

This covers loading previously existing contracts from the DB when initializing the node, but what about creating new contracts? For that, we have to add new functions to the `ContractManager`. For example, if we have an ERC20 contract with the following constructor declaration:

```cpp
/// Constructor when loading contract from DB.
ERC20(
  ContractManager::ContractManagerInterface& interface,
  const Address& address,
  const std::unique_ptr<DB>& db
 );

/// Constructor to be used when creating a new contract.
ERC20(
  ContractManager::ContractManagerInterface &interface, 
  const std::string& erc20_name, 
  const std::string& erc20_symbol, 
  const uint8_t& erc20_decimals, 
  const uint256_t& mintValue,
  const Address& address, 
  const Address& creator, 
  const uint64_t& chainId, 
  const std::unique_ptr<DB> &db
);
```

Where the initialization of the contract is done like this:

```cpp
ERC20::ERC20(
  ContractManager::ContractManagerInterface& interface,
  const Address& address,
  const std::unique_ptr<DB>& db
) : DynamicContract(interface, address, db), _name(this), _symbol(this), _decimals(this), _totalSupply(this), _balances(this), _allowed(this) {
  ...load variables from db...
}

ERC20::ERC20(
  ContractManager::ContractManagerInterface& interface,
  const std::string& erc20_name,
  const std::string& erc20_symbol,
  const uint8_t& erc20_decimals,
  const uint256_t& mintValue,
  const Address& address,
  const Address& creator,
  const uint64_t& chainId,
  const std::unique_ptr<DB>& db
) : DynamicContract(interface, "ERC20", address, creator, chainId, db), _name(this), _symbol(this), _decimals(this), _totalSupply(this), _balances(this), _allowed(this) {
  ...load variables from arguments...
}
```

These functions must take into account the constructor arguments of `DynamicContract` and its own contract. For example, the `DynamicContract` takes `interface`, `contractName`, `address`, `creator`, `chainId`, and `db`, which the constructor must take as:

| DynamicContract constructor argument | Taken from                                   |
|--------------------------------------|----------------------------------------------|
| interface                            | this->interface                              |
| contractName                         | The Contract class name as string            |
| address                              | derived using this->deriveContractAddress()  |
| creator                              | this->getCaller()                            |
| chainId                              | this->options->getChainID()                  |
| DB                                   | this->db                                     |
The interface allows the contract to interact with other contracts and the native token balance of other addresses on the chain, effectively accessing the State class to get the balance of an address. More information about it is located within the next section.

`contractName` is the name of the class, which is not argumented to the class directly; instead, the class constructor initializes it during the initialization list. It is used to identify the contract during loading. The address is derived using the `deriveContractAddress()` function, which is a function that derives the address of the contract using the address of the creator and the nonce of `ContractManager` (differentiating from EVM, where the account nonce is used). `creator` is the caller address, `chainId` is the node's chain ID, and `db` is a pointer to the node's database.

In order to integrate the constructor for creating a new ERC20 contract, we need to add two private functions to the `ContractManager`: one for creating the contract and another one for validating if a given transaction can create that contract. Those functions must be called `createNewCONTRACTNAMEContract()` and `validateCreateNewCONTRACTNAMEContract()`, where `CONTRACTNAME` is the class name of your contract. For ERC20, we will need to add the following:

```cpp
/// Create a new ERC20 contract.
/// function createNewERC20Contract(string memory name, string memory symbol, uint8 decimals, uint256 supply) public {}
void createNewERC20Contract(const ethCallInfo& callInfo);

/// Check if transaction can actually create a new ERC20 contract.
/// function createNewERC20Contract(string memory name, string memory symbol, uint8 decimals, uint256 supply) public {}
void validateCreateNewERC20Contract(const ethCallInfo& callInfo) const;
```

Notice that the function declaration has a commented Solidity function above it for reference. This function must consider the arguments for your contract as if it were a Solidity contract. You can add this function to your `ContractManager` JSON ABI and call it with any Web3 client to create a new instance of the contract. Let's delve deeper into how these functions are implemented.

The derived contract address can be described as: `sha3(rlp(tx.from() + manager.nonce()).substr(12);`. Its implementation is as follows:

```cpp
Address ContractManager::deriveContractAddress(const ethCallInfo& callInfo) const {
  uint8_t rlpSize = 0xc0;
  rlpSize += this->getCaller().size();
  /// As we don't have actually access to the nonce, we will use the number of contracts existing in the chain
  rlpSize += (this->contracts.size() < 0x80) ? 1 : 1 + Utils::bytesRequired(this->contracts.size());
  std::string rlp;
  rlp += rlpSize;
  rlp += this->getCaller().get();
  rlp += (this->contracts.size() < 0x80) ? (char)this->contracts.size() : (char)0x80 + Utils::bytesRequired(this->contracts.size());
  return Address(Utils::sha3(rlp).get().substr(12), true);
}
```

Effectively, the function for creating or validating the creation of a new contract must also check if the address is already in use, throwing an exception if it is. The function for validating must only check if the creation is actually valid, whereas the function for creating should store a new contract instance within the `this->contracts` map.

The implementation for both functions for ERC20 is as follows:

```cpp
void ContractManager::createNewERC20Contract(const ethCallInfo& callInfo) {
  if (this->caller != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can create new contracts");
  }
  /// Check if desired contract address already exists
  const auto derivedContractAddress = this->deriveContractAddress(callInfo);
  if (this->contracts.contains(derivedContractAddress)) {
    throw std::runtime_error("Contract already exists");
  }

  std::unique_lock lock(this->contractsMutex);
  for (const auto& [protocolContractName, protocolContractAddress] : ProtocolContractAddresses) {
    if (protocolContractAddress == derivedContractAddress) {
      throw std::runtime_error("Contract already exists");
    }
  }

  /// Parse the constructor ABI
  std::vector<ABI::Types> types = { ABI::Types::string, ABI::Types::string, ABI::Types::uint256, ABI::Types::uint256};
  ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));

  /// Check if decimals are within range
  if (decoder.getData<uint256_t>(2) > 255) {
    throw std::runtime_error("Decimals must be between 0 and 255");
  }

  /// Create the contract
  this->contracts.insert(std::make_pair(derivedContractAddress, std::make_unique<ERC20>(
    this->interface,
    decoder.getData<std::string>(0),
    decoder.getData<std::string>(1),
    uint8_t(decoder.getData<uint256_t>(2)),
    decoder.getData<uint256_t>(3),
    derivedContractAddress,
    this->getCaller(),
    this->options->getChainID(),
    this->db
  )));
  return;
}

void ContractManager::validateCreateNewERC20Contract(const ethCallInfo &callInfo) const {
  if (this->caller != this->getContractCreator()) {
    throw std::runtime_error("Only contract creator can create new contracts");
  }
  /// Check if desired contract address already exists
  const auto derivedContractAddress = this->deriveContractAddress(callInfo);
  {
    std::shared_lock lock(this->contractsMutex);
    if (this->contracts.contains(derivedContractAddress)) {
      throw std::runtime_error("Contract already exists");
    }
  }

  for (const auto& [protocolContractName, protocolContractAddress] : ProtocolContractAddresses) {
    if (protocolContractAddress == derivedContractAddress) {
      throw std::runtime_error("Contract already exists");
    }
  }

  /// Parse the constructor ABI
  std::vector<ABI::Types> types = { ABI::Types::string, ABI::Types::string, ABI::Types::uint256, ABI::Types::uint256};
  ABI::Decoder decoder(types, std::get<5>(callInfo).substr(4));

  /// Check if decimals are within range
  if (decoder.getData<uint256_t>(2) > 255) {
    throw std::runtime_error("Decimals must be between 0 and 255");
  }

  return;
}
```

Additionally, it is possible to add a check to see if the contract creator is the chain owner. This is currently done within OrbiterSDK to prevent a user from creating an infinite number of contracts. However, developers are free to change the requirements for creating a contract. Moreover, the implementation verifies that the address is not in use and checks the arguments of the contract, following the Solidity function ABI.

Finally, it is necessary to add the function into the `ethCall()` of `ContractManager`. To do this, we need to calculate the function signature and add an if condition for the function, which is done as follows:

```cpp
void ContractManager::ethCall(const ethCallInfo& callInfo) {
  std::string functor = std::get<5>(callInfo).substr(0, 4);
  if (this->getCommit()) {
    /// function createNewERC20Contract(string memory name, string memory symbol, uint8 decimals, uint256 supply) public {}
    if (functor == Hex::toBytes("0xb74e5ed5")) {
      this->createNewERC20Contract(callInfo);
      return;
    }
    /// function createNewERC20WrapperContract() public {}
    if (functor == Hex::toBytes("0x97aa51a3")) {
      this->createNewERC20WrapperContract(callInfo);
      return;
    }
    /// function createNewERC20NativeWrapperContract(string memory name, string memory symbol, uint8 decimals) public {}
    if (functor == Hex::toBytes("0x9f90f4c7")) {
      this->createNewERC20NativeWrapperContract(callInfo);
      return;
    }
  } else {
    if (functor == Hex::toBytes("0xb74e5ed5")) {
      this->validateCreateNewERC20Contract(callInfo);
      return;
    }
    if (functor == Hex::toBytes("0x97aa51a3")) {
      this->validateCreateNewERC20WrapperContract(callInfo);
      return;
    }
    if (functor == Hex::toBytes("0x9f90f4c7")) {
      this->validateCreateNewERC20NativeWrapperContract(callInfo);
      return;
    }
  }
  throw std::runtime_error("Invalid function call");
}

```

## ContractManagerInterface - Allowing contract to access balance

The `ContractManagerInterface` class is a nested class within `ContractManager`. It is used to allow the contracts to interact with other contracts and to enable them to modify balances. The definition of the class is as follows:

```cpp
class ContractManagerInterface {
  private:
    /// Reference back to the contract manager
    ContractManager& contractManager;

  public:
    /// Constructor
    explicit ContractManagerInterface(ContractManager& contractManager) : contractManager(contractManager) {}

    /// Populate a given address with the balance of the State
    void populateBalance(const Address& address) const;

    /// Call a contract function.
    /// Used by DynamicContract to call other contracts
    /// @param callInfo The call info
    /// A given DynamicContract will only call another contract if it was firstly triggered by a transaction.
    /// That means, we can use contractManager::commit to know if the call should commit or not.
    /// THis function will only be called if a ContractManager::callContract or ContractManager::validateCallContractWithTx was called before.
    void callContract(const ethCallInfo& callInfo);

    /// Get a contract by address
    /// Used by DynamicContract to access view/const functions of other contracts
    template <typename T> const T* getContract(const Address& address) const {
      std::shared_lock<std::shared_mutex> lock(this->contractManager.contractsMutex);
      auto it = this->contractManager.contracts.find(address);
      if (it == this->contractManager.contracts.end()) {
        throw std::runtime_error("ContractManager::getContract: contract at address " + address.hex().get() + " not found.");
      }
      T* ptr = dynamic_cast<T*>(it->second.get());
      if (ptr == nullptr) {
        throw std::runtime_error("ContractManager::getContract: Contract at address " + address.hex().get() + " is not of the requested type: " + typeid(T).name());
      }
      return ptr;
    }

    /// Returns the balance from the State
    /// Doesn't take account of current transaction being processed.
    uint256_t getBalanceFromAddress(const Address& address) const;

    /// Send tokens to a given address
    /// Used by DynamicContract to send Tokens to other Contracts
    /// @param address The address to send the tokens to.
    /// @param amount The amount of tokens to send.
    /// Uses currentActiveContract to know which contract is sending the tokens.
    void sendTokens(const Address& from, const Address& to, const uint256_t& amount);
};
```

The reason for using an interface instead of accessing `ContractManager` or the State directly is to be able to do it in an isolated and secure way. For example, if we want to send tokens from a contract to another address, we don't access the balance directly from the State. Every time a function is called by a **user** (not another contract), the balances map available for contracts is empty, only populating what is currently being accessed and not previously available. When modifying the balance, only the mapping within `ContractManager` is modified, therefore allowing for multiple nested contract functions to revert and not affect the State neither other contracts.

There are two methods for Dynamic Contracts to access other contracts on the blockchain: one for calling only view functions, and another for calling payable and non-payable functions that can affect the variables of the blockchain. The first one is done by casting the contract pointer from the inner `ContractManager` mapping to the desired contract type as `const`, therefore only allowing view functions. The second one is done by casting the contract pointer from the inner `ContractManager` mapping to the desired contract type as non-`const`, therefore allowing view and non-`const` functions.

We use `this->interface.getContract<CONTRACTTYPE>(address)` within a contract function in order to access that contract if existing within that address. Take note that if the type check fails, it will revert. Calling a non-`const` contract function is another thing, because it is necessary to only do the call through `ContractManager`, otherwise `SafeBase` variables won't be affected by a revert.

This is done by calling `this->interface.callContract(address, ethCallInfo, value_if_payable)` within a contract function. This will call the function within that contract with the proper safety checks in place. It is necessary to properly encode the function signature and arguments within the `ethCallInfo` following Solidity rules. The implementation for `callContract()` is as follows:

```cpp
void ContractManager::ContractManagerInterface::callContract(const ethCallInfo& callInfo) {
  const auto& [from, to, gasLimit, gasPrice, value, data] = callInfo;
  if (value) {
    this->sendTokens(from, to, value);
  }

  if (!this->contractManager.contracts.contains(to)) {
    throw std::runtime_error("Contract does not exist");
  }

  const auto& contract = this->contractManager.contracts.at(to);
  contract->caller = from;
  contract->value = value;
  contract->commit = this->contractManager.getCommit();
  try {
    contract->ethCall(callInfo);
  } catch (std::exception &e) {
    contract->commit = false;
    throw std::runtime_error(e.what());
  }
}
```

Every time `sendToken` or `getBalanceFromAddress` is called, it calls `populateAddress` to grab the balance from the State and populate it within the `ContractManager`. It also verifies if the contract has enough balance to actually send the tokens - if not, it will revert. The implementation for functions that access balances is as follows:

```cpp
void ContractManager::ContractManagerInterface::populateBalance(const Address &address) const {
  if (!this->contractManager.balances.contains(address)) {
    auto it = this->contractManager.state->accounts.find(address);
    if (it != this->contractManager.state->accounts.end()) {
      this->contractManager.balances[address] = it->second.balance;
    } else {
      this->contractManager.balances[address] = 0;
    }
  }
}

uint256_t ContractManager::ContractManagerInterface::getBalanceFromAddress(const Address& address) const {
  this->populateBalance(address);
  return this->contractManager.balances[address];
}

void ContractManager::ContractManagerInterface::sendTokens(const Address& from, const Address& to, const uint256_t& amount) {
  this->populateBalance(from);
  this->populateBalance(to);

  if (this->contractManager.balances[to] < amount) {
    throw std::runtime_error("Not enough balance");
  }

  this->contractManager.balances[from] -= amount;
  this->contractManager.balances[to] += amount;
}
```


## Not breaking your blockchain when using ProtocolContract

Protocol Contracts do not offer the same level of ease of use and security as Dynamic Contracts; however, by sacrificing some of these features, they enable more complex functionalities that would be impossible to achieve with Dynamic Contracts alone. For instance, Protocol Contracts can call functions without an active transaction call when processing a block, access files within the system, and make requests to other nodes.

Introducing this new layer for processing information inherently carries risks, particularly in a decentralized network. To maintain a stable network, you must ensure that every node can execute the same operation, given a previous context. In a typical VM blockchain, this is achieved by allowing operations to be callable only by transactions and packaging these transactions into a block. When processing a block, all transactions that call a contract attempt to execute, ensuring that all operations are performed consistently within the given context.

As a developer of a Protocol Contract, it is crucial to manage the processing of information in a way that ensures different nodes do not arrive at different results when given the same context. The challenge lies in defining "context". In a VM blockchain, the context can be defined based on a block and all its past blocks. However, in OrbiterSDK, Protocol Contracts that process beyond a transaction call are actively changing their own context. Consequently, it is essential to guarantee that the context remains consistent across all nodes.

To avoid potential issues when developing Protocol Contract, follow these best practices:

* *Clearly define the context*: establish a clear definition of the context for your Protocol Contract and ensure that this definition is understood and adhered to by all nodes in the network
* *Use deterministic processes*: ensure that any processes or operations within the Protocol Contract are deterministic, meaning they will always produce the same output when given the same input. This will help prevent discrepancies between nodes
* *Limit external dependencies*: minimize the reliance on external data sources or systems that could introduce variability into the context, making it more challenging to maintain consistency across nodes
* *Implement thorough testing*: test your Protocol Contract extensively under various conditions and scenarios to identify potential issues and vulnerabilities. This includes simulating different network conditions and node configurations to ensure consistent behavior
* *Maintain clear documentation*: document your Protocol Contract design, functionality, and context requirements in a clear and concise manner. This will help other developers understand how to interact with the contract and maintain consistency across nodes
* *Monitor and update*: continuously monitor the performance and security of your Protocol Contract after deployment. Address any issues or vulnerabilities that may arise and implement updates as necessary

By adhering to these best practices, you can create Protocol Contracts that maintain consistent behavior across nodes, and ensure the stability and security of your blockchain network. Remember that the key to developing robust Protocol Contracts lies in managing the context and ensuring that all nodes in the network can process information the same way.

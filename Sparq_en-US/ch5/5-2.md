# 5.2 - P2P Overview

This subchapter provides a comprehensive overview of the P2P classes and their organization within the OrbiterSDK. It further elaborates on the life-cycle of a P2P connection and the dynamic flow of data between nodes.
## P2P::Session

The Session class serves as a fundamental base class for both ClientSession and ServerSession. It encapsulates a TCP connection with a remote node, transforming it into a "session", thereby streamlining the process of sending and receiving messages.

The Session class is responsible for managing the handshake process, reading socket data, and dispatching messages. It incorporates a queue for outbound messages, allowing any thread that is responsible for sending a message to carry on with its task without having to wait for the message transmission to complete.

The Session is designed to be used with shared_from_this to manage its lifecycle, as it primarily exists within the handlers of io_context. Once a session has successfully established a connection with a remote node, it is added to the P2P Manager's list of sessions.

It is critical to properly manage this shared_ptr. The destructor of the Session class is intrinsically linked to the destructor of the socket, which, in turn, calls the io_context. If the shared_ptr persists but its referenced io_context is no longer existent, this will lead to a program crash.

For instance, functions called by the thread pool to parse asynchronous operations accept a std::weak_ptr as a parameter, which is then converted into a shared_ptr. This design choice ensures the Session object is still viable. In addition, the manager session mutex is locked to prevent the shared_ptr from unexpectedly becoming a unique shared_ptr and causing a segmentation fault while attempting to delete a session in the absence of its corresponding io_context.

Here is a pseudocode representation of the base Session class:

```cpp
class Session {
  protected:
    boost::asio::ip::tcp::socket socket_;
    std::shared_ptr<Message> inboundMessage_;
    std::shared_ptr<Message> outboundMessage_;
    std::deque<std::shared_ptr<Message>> message_queue_;
    const uint64_t maxSize_ = 1024 * 1024 * 128; // 128MB
    BytesArr<3> inboundHandshake_; 
    BytesArr<3> outboundHandshake_;
    BytesArr<8> inboundHeader_;
    BytesArr<8> outboundHeader_;
    std::unique_ptr<dynamic_vector_buffer> inboundBuffer_;
    std::unique_ptr<dynamic_vector_buffer> outboundBuffer_;
    std::mutex queueMutex;
    void virtual write_handshake();
    void virtual read_handshake();
    void virtual finish_handshake();
    void virtual do_header();
    void virtual on_header();
    void virtual do_message();
    void virtual on_message();
    void virtual write_add_queue();
    void virtual do_write();
    void virtual on_write();
    void virtual handle_error();
  public:  
    Session() {...};
    void virtual run();
    void virtual close();
    void virtual write(std::shared_ptr<Message> msg);
}
```

The life-cycle of a session can be described as follows:

Upon instantiation, a session's run() method is invoked. This method dispatches write_handshake() using boost::asio::dispatch. This function, in turn, utilizes boost::asio::async_write to send the handshake, setting read_handshake() as its callback. Following this, read_handshake() initiates an asynchronous read operation to receive the remote endpoint's handshake, using finish_handshake as its completion handler. The finish_handshake method then validates the received handshake through the P2P Manager and proceeds to call do_header(). This sets off a sequence of operations: do_header() leads to on_header(), which in turn calls do_message() with the size information derived from the header buffer. After this, do_message() triggers on_message() and passes the received message forward for parsing. Finally, do_header() is invoked again, setting up for the next round of data exchange. This process continues cyclically for the duration of the connection.

Here is a flowchart of the process:

```mermaid
---
title: "Inbound Flow"
---
flowchart
	514031(("run()")) -->|"boost::asio::dispatch(socket)"| 172834(("write_handshake()"))
	172834 -->|"boost::asio::async_write()"| 312101(("read_handshake()"))
	312101 -->|"boost::asio::async_read()"| 529616(("finish_handshake()"))
	529616 --> 868643(("do_header()"))
	868643 -->|"boost::asio::async_read()"| 142304(("on_header()"))
	142304 --> 928447(("do_message()"))
	928447 -->|"boost::asio::async_read()"| 625376(("on_message()"))
	625376 --> 868643
	529616 -->|"Valid Handshake?"| 993235{"P2P Manager Reference"}
	993235 -->|"Close Connection"| 554594(("close()"))
	529616 -->|"Register Connection"| 993235
	245324(("handle_error()")) -->|"Close Connection"| 554594
	245324 -->|"Deregister Connection"| 993235

%% Mermaid Flow Diagram Link
%% Keep this link to make future edits to your diagram
%% https://www.mermaidflow.app/flowchart#N4IgZgNg9g7iBcoB2UAmBTAzgg2qGAlqgC4AWCAjAMwBsANCKegQOanGW0NEIgUAsAJioAGfiAYAHKJgLECUJAlAAPBFQCc-AHT8NNfiJEBWTRTHCGATwQb92gOwONFGlofmH-AL4NUAQ2J-ZRAAYwh-TEwsXABdBkxiKwgY+Bx4kAiAI3QIXkUAfSZ-DAAnAAoASgkQVAJS9FD5RV4AFQAhGtL-JABrTAARbpglRF8QSX8GpGIAJR7ehBE-YYBlJJSEYlKAV3RxpMl0XlD68PQAOTRjhI3jsYTcxuJ0VAQwfwhoqRk5BSQAIJZTBQCA7F4hNTwTQ6PQGIymFwWKjWWz2JwuNz8DwiLzjVDdFgsAhIFjvT7RXz4IhkTj0RjMNgceDUek8eB8ByCAAcVHEP1kzVGqnUNAo2ioDkl-GM3IMgicxlR8EExgc2lx2L0FC53OM+vxgWCiDCESiqXSt2SFoy2VyvBgpTk6CKPVQmFI-l66CqNTqDSa-zanQY3T6g2GwvGk2mcwWSxW-hg62tW12+wYh3uYTOKSuGBqiVTDxA0RSTVe5K+6AFf0UQJBYIhJqhtHFkulsvliuVqvVmq8Ll1+uM3ipIEIJHILK4DNY7Dp3DeHMEMqoq5q0kFQZbCAAtAJBNpBC5jBQ5TRuYIRNz+CiQDYVZptBQTzRV7LjGJzBpDUEQuEkTRNgaQZEWKQgZamT+DkeQcp6SCoCkBToKUpRQBU1R+PUzw7iAHRdAsEZJlGUhTOgMzzH0Ca1GsdxpnsBxWEcJy5pc1yFvRJZls8lbwB81a1kKDaguC9wivAB5CMep7njQl7Xre96PsIGgvm+H56t+Ii-uOk60jO9JMPOzKskuvBUK+5gUJuvxCpC6jGPSj78K+f7GqAgHmpBYF3D5DB2nBIANCUrqIR6Xo+lhtQ4YGLQcgRoZEUMJHKNG5GUfG8DLLRSYpps8DbIxmbMdmpylOc+Y3KWXHAOMPEVsuAnfBMdn-CJTbiSArZOcqrmCGOdDUlOi5zkyo3siAZ6GJZtnbvFElUGqGpeIOOo8iOyrmCI7kAWawFxFaEGHdBsG8LsSC+thAb2QlIbBclkZpWRsZUYs2WJsmXFFRmIBZqxFV5hxR3ifVTyNVWLVbnWgLAqJzaLctA7asO+pbUYg3DQZZljQuhnmRyxhvq4c0ww50K9Q+CBOdyu0ml5B2gSD-mnfaHJgCSBAemF7qet6V0xTdeGJQ94YpSMz0TBlcbUR9uVfcWP1MSxHLlZVwM1cWdWPOWLxNRSNatfNsONmJ5NLc51OXpjE40tOOPGeN+MgJN+oylopO3RJ55HloGhOPwrk0CIghioIvZ6tol4aDy3LUDHt7yXTnn7TazMnYFJzQNEAv+rh8X4fdYb9OLpFS69WU5QSeXfemytlWxVWcVrYO63xzWG9Dwlw515M+9ofsB0HIdhxHxhR9yCdx5oPL8Enel26Njt4zjk3vqYDg0J7O7eyIx7Yh4FBqnKRMiMpCDcg44-+2er5UNyeqrlQyemkBaea8dTOs0FhQALZYJgfwLAop+lirdQuhExZPRLDGCiMt3pVzoorOuJUVY5kBuxAsINJYNT1pDTubV6w9zNruFke9VxOAoEfBwJ9rzn3gJfa+V8qHCAfkTO8+JCTElJPgheI1nbL1MrOSaco5R3m3gtbq6gqBUAlDI+RCj5HKk3j4PwRo9pvxZuBd+mcOSoCgEUdAJRUK5zAcLIuj1UowOlm9Gi1cFYFSVqghuGCm7YO4uDPB-EDZCXasQhGUjoQyLkYo0JyiDA230vbWcgiJrLhAAnQODgJHCkCdeHKj4qGuBfgzd+2iWa6NqAY-+UQgEgOuvnUYECkpQKsdrcucDbFy3sfle4Ti-qlQBurLBH9QY614vrQSRsYYdRIRJdJW0qE0EiYvARjIV7CPiXYdcS0UnkwcHvQwYiKAaBkcYQOd5lRflhKIQ865XKTw4Wo-89NU5aL8hnGCbMQAAAVBAvIAAQAFkehlNKB82Y6AwCoQoqEaqec4pVJFsXYiEtrEV1logmuyDiodLQaUUgUBf5ZB2JgNxvScGePbj44Z3dTYBKhBs3QN4DA7L2Qc+hxzdCnKEOc88Whn7eAyK8YBkFQD-VVri4gWKai-ymN6Uo6wpjMhAFAI4SgGBitKBKgAoohXg0gSQcG4DMVC-hIUAHVZnXncaARI6FvRGv4RQcYk0eXoD3GqVw8kTxDmSQkKAOwKrZmmmfGymYpjAJletXk-I-qBvQMQAAEm6AqfBCyeu9TGxCcb-W1HUSaQpWQoAyGIPAeAkQFD5rqJgSYxBQikHKCCUI3piDRRSKSbG4wABeABJRC6AoTbX6RDbx1ZxwCrCEKkVirxWoSlaUGVcqKKirHaUNV8TNUzBqFqvVhrjU5W0SEc1UBLWzJtQTEA9q9y0H2ZPFw1ARBppBF6sFvAQ18hqEEUoQaLJWSvU+iN0bY3ZmvYmsFyakK-r9Bm0AWac2JHzYWqAUHMBWCQKEAojpnQCwbSwJtDA20dq7UYHtXiO4Ds6YKxII6QBKolROqd8rZ3KtQgujVUAtUrt1d0dd-CTUEpNDuvd1rbXxOPUtLwrgjCXg-R6292ZLKCGsp+l9kbeBE30CTANcnv0puA+JpNP770gZuWBp5QVs25tg0WgtcGEMFBCqgVDFF0P2xbe2jAOHN1EsGZSIaaKyrDt-jRijz6qMztHbR+d6qORLu1S7Fj+qhRWoMhxrdXHti7vQLF+zh7j1nnXJeOe645QJokwp4mW8VOvo5KIgwVBZNBsA6m-LWn1M6euR5b+vAahoYwyALDTnKC4dLK53hHnB2hG8758d-n8jUaC6q0LrUmM6peKxmLG7TU1QtSl-dfHeDHp1JfDauy+x1bvWVy8FWqvyY5GcsQZ21NAca6Wf96AasafTXplrHIjOQbM6ZyI8HENWZs42+23BMAqrqPIHhfb3Odcc52nrLm25uYzPyojQ6SM+am2N6VE3AtkbnfRsLjHl3zbXUt9jm7aqreS6lygm2OQCc0KYeEOlryHd-ayq7JXzsJNntia7T27s3vq7di7unmuFLa7ZjrXXYdkPhwMgbyO0HDbR6NyV42OTToVbj4L+PZtE8iwt6L-xqcqnJ1rSnPGOt2tQMAvcYiaG4hEDQImxX7sFY5Ik3nnOZXr0lK7591XtMi80wBoP8amshHA8Zr7MGzO-cs0Y6z9bJdA5diDsHJIySQ9+tL5zeHiX9sGyj5Xwr0fa781jjXk3y90Zm+F5jhu2NxbNwVM1SXLdpZdvxm3Drdshw7Ps2grPeC+83td3g5XxHe-58Ht3QvasR8zQZ1rAUU808wzDvPfWEcK88ycEbGO1eV9ldX8jtfF2E4i6uxbxvlucbb2tk3B6u9bZ73uJJGgr00BhIIQQw-CZFbj4e77arLT5h5-oSYz7h4vZi7L4cgABqnwRAHygGEU3oAA-BLoDuvtDthnDvnojoRkrgfjXkfpOtjlrmfiFhfnNgbiTrfmTittxutrxulm-ktIHFeteL-vfP-gkiAcYEAVNPssYB7GAQ1rPoLqHhIdAQEK9oUgAMLZzoAfIKGKBICVJYF2Y4G574Hb7y7Z5EFeYq6H6UYUGq66717E436KAm7xYU7MFP605Hpv7O5nxeBPy-7upz5HZTSAHe68DLLCCCHiHC7QFSGPbgGi6R5wEgCArEiJCoSqHqGaGr7YEsgOZ4Gy4EG75DYkFUFmFV445UGWGX4N70G2F34JYP5U4bZsG25ihnw6SSiDiVYh7ZgfjnJCFuyiFhoB6RpQEQHz7PZyGwFnQchKEyAqFqFIAaGQpaFS6b56G4IF7uaK7GGl6q6FEn7FF4515lHWFG6VGMH34W4sFW7d624Kgxy0BiBXrrh8GdEbgBHAErIhHhqqaDGs5fGL76bjEgADAgoJELbJGzGpGZBr4ZEb5ZHdr6G9oEYZAABuBA6AMA0g5BpC64jgwcZ8XhV8J4fuyoe414NAEowg14Tkl4t4V494zaOaPm2U2JSkV8n+BghgJgDgg0MUQC3Qv8Xyka-gAwoGgsmhd0NQYA6EMwPyxAC2IQ8gxAca7a2aOwiEHyAAYtAHAPiGYoie-KEFiv-DMCzLkj5LaiDioOicQC8j0LkAAPLUaFTpgMAsDQBZCfCg7AKtBEagCoA7CfD4IBQkjoBeloKNg8AMD2o-LBYhnZia41D6nQClC8AADEWQFAaZWQW84wLpUAbpEAVUMZcpKON0PQLpmC1UCZGEKZRgNZIgNQbpNaLA6EKpqAahiZKZYAnZXZ9ZGEZQbZVZHIyZtZRgPZpQZQrQpABANaGhUQvAYZbwwOQpHoqx+w3gQAA
```

For messages originating from the local node (outbound messages), the process is outlined as follows:

An external thread invokes the write() function, supplying a shared_ptr<Message>. Within this function, the queueMutex is locked, and a check is made to see if the outbound message is null. If it is, the outbound message is assigned the Message passed as an argument, and boost::asio::post is called with do_message_header() as it's handler, with the appropriate write strand. If the outbound message is not null, indicating an ongoing message write process, the argument Message is simply added to the queue. The write strand is designed to handle it at a later time.

The write strand initially sends the header (comprising 8 bytes that contain the message size), followed by the message itself. This sequence triggers the calling of functions in the following order: do_write_header() -> on_write_header() -> do_write_message() -> on_write_message(). The function on_write_message() stands out as it locks the queue mutex, transfers any message from the queue to the outboundPtr, and subsequently invokes do_write_header() again. If the queue is empty, the outboundPtr is set to null, bringing a halt to any further callbacks from the write strand.

```mermaid
---
title: "Outbound"
---
flowchart
	311944(("write()")) -->|"boost::asio::post() if condition is met"| 474425(("do_header_write()"))
	474425 -->|"boost::asio::async_write()"| 476584(("on_header_write()"))
	639173(("do_message_write()")) ---|" boost::asio::async_write()"| 562806(("on_message_write()"))
	476584 --> 639173
	562806 -->|"if queue not empty, move ptr and call<br>"| 474425

%% Mermaid Flow Diagram Link
%% Keep this link to make future edits to your diagram
%% https://www.mermaidflow.app/flowchart#N4IgZgNg9g7iBcoB2UAmBTAzgg2qGAlqgC4AWCAjAAwBsANCKegQOanGW0NEIgDMFCgE4ALCJAMADlEwFiBKEgSgAHggDsNdQDpBFABwBWGvqojD6gEyWGATwSX1Q7TUOH9mkRT6P9AXwZUAENiIOUQAGMIIMxMLFwAXQZMYlsIePgcJJBogCN0CF4YACc5dAAKAEoJEFQCYvQI+UVeABUAIRrioKQAa0wAEW6YJUQAkEkghqRiACUe3oQqQOGAZVT0hGJigFd0cdTJdF4I+qj0ADk0Y+SN47HkgsbidFQEMCCIOKkZOQUkACCuUwUAgOxe4TU8E0Oj0RhMZgs1jsDicLjcHhoXh86n8KyCLBYBCQLHenziAXwRDIlCxDCYrHYtJE3De8BAInUYkshhq0lkzVGqg0VD42ioQhoCLEIi0ZhR8EMIjFVAoIlVFEsBiE1Bo42CoXCURicWwmWyKTSGSyDDyBV4qCgAH0mEEMMUnSUylUanUGk1-m1Ogxun1BsMheNJtM5gslviYOsrVtdvsGId7pEzukrhgapbNg8QHF0k1XmSvugfgL-kCQWCIYgQFD1KLxZLpWI5SyQPZFcrxWqNVr9DraPruoTiaT4B9K5SQIQSOR4BQ6YxmGwOKv1zx2ZzXPpxNW-i0my3LDRtEI+HxTFYREJ1N59AqnzpL63RU5zM+8bUQjCJtjVia0LTuM0bRyIJ8kKdlFBddA3XQD0vReH1AnqZ5A3ZDougWcMghGZQoymdAZnmPp41qNY7hTPYDlsI4TmzS5rnzOiixLZ5y1nckqwmX5BTrUFwXuYVoUva9b3vSxH2fO833UD85W-UQLAMPwFyXGlVycelNyZPShFZXhjEsUwaD5IScIknlnCsdRjCoXE+FFPhXAVLRLG0QwqCodw701TUhH1QCjWiUDIPAq1ottGD7XgpAnQAWywTACXQT1SnQ6pMP9QUg3wsMhiIyMpDIii43gZYaKIpNC22Bj0yYzNTmKc5cxuYtOOAcZuLLNk52+QSa0UESG3E5sHEMBzHGc1z3M83sEG83z-MC-RgssUL8SnEkKwpOgqWXSh9I3Rltwoc69xAGg+B1dQ+GssahWm+BHyobR9C1PgMScP63HoFb4CfMV7vMREREcSwwsNYDItNRJbli5HoNgh1nTS2JMuy708tqLCAzPEA8JDAjSuIoto3I2MqJqhMGvuJq0xADMWI6nN2JRws+seUsXiG-iT2E4FRMbCTPu+37-pvNxjCU8G+Eh8xoasCcCSJA6+PnbJXhYa1QHZ9kIh2FIoBSmoUqmXoUPWKZtxAKAjiUBhreKW3igAUSQNlBOJDhuBmFCgmJpAAHVqRXSxaoLKaUmKKBbcj07V3GW79fQABaVsaCoI8dpEfR7vzKAdg6zMBGEMQalCYoDcdzluV5dMpgbgAJHpUELEAKFL8uInQTvfZ7vvAnCps7TgkBcigGRiHgeAYgURf+WIKoAAICDADeIkUOpBS3zAN7SwOcnIlhdIobhMC9g-p0O1mAC8AElffQKFqFjp5BsfhdjciGbYgFsrY2ztnXR2ztyKgI9ihH2ftpABxqAHEOYcU66RjjzeO2wk7oHQSuCg6c-aZyzmuYws1lLuFlP3CuvAm7QxbmzNu6BG6aCobXZhxBh7d0zGPYsZcK7cNHr6CeoAp68FnvPRey8oDSMwLYJAEQ8a5RqOkEkV8b53z+NrYaz834YE-v5fmPEhbzmOmzVqJwgEgLdmA4o9tiiQJdjAz28DeBQNdiAFB3Q0FRwcLHXqPVE7Jz8WnZIAjB68Huo9Z64SB5Dy7sI1u9cWFmRoBZWgHCUlcMSZmSwyDiGoANjnHUys+C4mfFiGoPQCDW0Fo-ce8NQBx1wEE3B8AADEuQKDdNyFZbIBBb73x0cLdGiUQAb0kSkORK8l7yMUcoio1Rxiv3foY7+AteK6P-pYk21jLa2NgfYiB7jnGHNcb7XgiCZjIODj4wU+D-FYPCAnXBjywn8PiXQthR4aGDyEXkrJDcokPWurEph2SAW8HyaZdkJC1Sq38tDIQAVqlIFqSELZoyDRAWaZxHAbTbadN6T0-pmjhkzm2QwVZBjOAbJMX-cxADTbmwOSAd2nsHFOOgecuBlz2TXLPt40ODzQmYJ6smJsryQmp0IXE2h7JzKWT+QkkevCgWpP3FyBhGqclqt4HwjORTs4eEfEIIwCknBooxfUnWI0cUvPxYS9AxKemkpAAMoZ2jKWjPEeybeG8ACOew9gbxQMQDe6AUqSFSHQE+UAABu6AN4xuKBvLuu9PgQAADy5GKAAPhACs-RH86XGN-na-Y2QE0EHQDAaQjjIQzS+tDcpnIMl50lHwBUxhxSWAEDQTUo55KqmpXPS2NVtCaCPOU2atAxD+T1PqAgBJugpQALIsKCAMURhMCo4VJsGcAicZjrpCC8Yo4R5DEB7gAeXBLPHYlzl37qTXFSIFs0ozHfSBJG5p063xUA24gAAFHoBRb3OPgCzBgLBoC5E+HfA2rRdmgFQDsT4DScjEnQCh5i7J6w8AYJnM9Ry8OZg8TUPe0BL3si6W6vpRbYPwc+F1cjV7dkgAKj0ODbE8wMGo1AWjIAOn+TE1QGoCGIi9BYInJ9qAADCoIhO8A6WAdTGnJNCfdEpmjqnxP+S08Ud0rRSAEGk0gdKvBCNvBvjuzATBTEUj8EAA
```

## ClientFactory

The ClientFactory Class serves as an intermediary that allows the Manager to instantiate and launch a new outbound Session given an IP address and port. It does not directly manage these instances, but rather facilitates their creation and execution within an io_context.

At present, the ClientFactory operates the io_context across four threads. This necessitates the use of strands to effectively manage and execute asynchronous operations within the Sessions.

The code snippet below, extracted from the ClientFactory Class, demonstrates how a new Session is instantiated and put into operation by the ClientFactory.

```cpp
  void ClientFactory::createClientSession(const boost::asio::ip::address &address, const unsigned short &port) {
    tcp::socket socket(this->io_context_);
    auto session = std::make_shared<Session>(std::move(socket), ConnectionType::OUTBOUND, manager_, this->threadPool_, address, port);
    session->run();
  }
  void ClientFactory::connectToServer(const boost::asio::ip::address &address, const unsigned short &port) {
    boost::asio::post(this->connectorStrand_, std::bind(&ClientFactory::createClientSession, this, address, port));
  }
```


## Server

The Server operates as a straightforward TCP server, listening for incoming connections and creating a new Session for each incoming connection.

Similar to the ClientManager, the Server's does not directly manage the Sessions. Instead, it focuses on accepting new connections, creating corresponding Sessions, and executing them within a designated io_context.

## ManagerBase and its Derivatives

The Manager acts as the backbone of the P2P network. It bears the responsibility of managing the Sessions, the Server, and the ClientFactory.

Once a Session has successfully completed a handshake, it is registered with the Manager, which then oversees the Session's lifecycle. The Manager's responsibilities include maintaining a registry of Sessions, handling incoming and outgoing requests and responses, and managing the communication amongst these Sessions.

Given its extensive duties, it's imperative that the functions within the Manager remain as "lightweight" as possible within their respective mutexes. This is to ensure the Manager is not locked for extended periods, as it is concurrently accessed by multiple threads to register/deregister Sessions, parse incoming messages, or request information from other nodes. Prolonged locking of the Manager risks blocking the node, with potential repercussions extending to the entire network.

Furthermore, the Manager oversees the operations of the P2P Server and ClientFactory, and therefore indirectly manages the io_context.

When discussing the Manager, it is important to be aware of some points before adding or modifying any code that uses it. Sessions do not manage their io_context, which means that if you retrieve a shared_ptr to a specific session, perform operations on it, and that pointer is deleted elsewhere, you could end up with a pointer that triggers an exception when used - because the io_context it refers to has already been destroyed. Awareness of the lifespan of the io_context and the objects that use it is crucial before adding or modifying any code that uses it.

## Request and Response Flow

Every incoming message is promptly parsed by the Manager via the handleMessage() function. These messages can fall into one of three categories: Request, Response, or Broadcast, and each type is handled distinctly by the Manager.

### Request

A Request message indicates a query for specific data from another node, which might include a list of blocks, transactions, etc. Upon receiving a Request, the Manager invokes the corresponding function to address the request and subsequently sends the requested data back to the originating node as a Response.

When the Manager initiates a request to another node, it generates a random 8-byte ID and registers this ID internally. Upon receiving a response, the Manager cross-verifies whether the ID is registered. If it is, the Manager fulfills the associated Request Future with the received response and removes the ID from its registry. However, if the ID isn't registered, the response is disregarded.

On the recipient's end, the node processes the request, formulates a response, and assigns it the same ID. This response is then dispatched back to the requesting node by the Manager.

### Response

A Response message signifies an answer to a previously dispatched request from the node. The Manager checks if the response ID is registered in its system. If it is, the Manager fulfills the corresponding Request Future with the response. If the ID isn't registered, the response is discarded.

### Broadcast

A Broadcast message signals a unilateral dissemination of certain data such as a new block or transaction. This type of communication contrasts with Request and Response messages which follow a bidirectional Request-Response flow. Here, the recipient node doesn't dispatch a response back to the sender. Instead, it verifies the received data and takes appropriate action, such as rebroadcasting the message or adding it to the blockchain.

### Assynchronous Message Parsing

The first thread under our control that accesses the Message is the io_context executing that particular Session. To optimize the performance of io_context and avoid any bottleneck, we offload the task of message parsing to a separate thread pool. This pool handles both parsing of the message and writing back to the Session, which involves adding tasks to the Session's write strand or queue.

One performance-enhancing strategy we employ is the use of shared_ptr for each Message. This prevents unnecessary copying of the Message and provides significant benefits when dealing with broadcasts. In such cases, a single Message instance can be utilized by multiple writing sessions, thereby offering a performance boost to the P2P network.

Our current design uses shared_ptr for all Messages. However, we plan to transition to a system where unique_ptr is used for inbound messages and shared_ptr for outbound messages. The rationale behind this is to better handle memory ownership. The use of unique_ptr provides clearer ownership semantics and improved performance. However, since unique_ptr cannot be moved into a std::function (which would be the task posted to the thread pool), we are retaining shared_ptr for the time being.

### Function Flow

The following diagram illustrates the flow of Message being received by the Manager, and the subsequent actions taken by the Manager.

```mermaid
---
title: "P2P Message Parsing"
---
flowchart
	309052(("Manager::handleMessage()")) -->|"if message is a request"| 922218(("\nManager::handleRequest()"))
	309052 -->|"if message is an answer to a previous request"| 479899(("\nManager::handleAnswer()"))
	309052 -->|"if message is a broadcast"| 931664(("Manager::handleBroadcast()"))
	508296(("\nSession::on_write()")) -->|"Call using thread pool task."| 309052
	922218 ---|"Call specific function for request (block, tx, etc)"| 512609(("Manager::handleREQUEST_TYPERequest()"))
	512609 ---|"Answer the session back if needed"| 178035(("Manager::answerSession()"))
	479899 ---|"Call specific function for request (block, tx, etc)"| 107692(("\nManager::handleREQUEST_TYPEAnswer()"))
	931664 ---|"Call specific function for request (block, tx, etc) "| 761803(("Manager::broadcastREQUEST_TYPE"))
	761803 ---|" rebroadcast the message if it is the first time seeing it."| 310567(("Manager::broadcastMessage()"))

%% Mermaid Flow Diagram Link
%% Keep this link to make future edits to your diagram
%% https://www.mermaidflow.app/flowchart#N4IgZgNg9g7iBcoB2UAmBTAzgg2qGAlqgC4AWCAzBQBwA0Ip6BA5qcZTfUQiAIwAMAdgBsATgBMIegAcomAsQJQkCUAA8EAFk38AdOImDqggKy9xmwbwrD6ATwTXRo3fwrP+-E9ROjfAX3pUAENiYNUQAGMIYMxMLFwAXXpMYjsIBPgcZJAYgCN0CB4AHWKkAFlgpGDmdAAneHhSKtQMgCUAUQBFAFUOgGUAFQB9QYBNAAUOgEEkTBh6gAoASikQVAI69EjFZR5BgCE1uqqAa0wAEROYFURAkGlgraRiNrOEfiDr-rSMhGI6gBXdD3NLSdA8SKbaLoAByaAhKV+ELuKUK22I6FQCDAwQg8RkcgUSiQ0zymCgEEBmIiGng2j0BnERlM5ks1lsIAc8CcLjcHi8Pj8onuqBOzGYBCQzBxePigXwRDICHEFnojBYbBVapA3HgfCMbhMa1k8l2t3UCGoLl4vE0vFE-AMbmotvE9kcrpc1GMOmZ1E0wmZFFFoXCiCiMTimWySPSMZy+UKPEq1VqDXgVXm9X6WHkyhWaw2Wx2JP2R3oJyQ5yuwRuqnuj2er3e8E+62+yP+QJB9DBKKi0Iy8Iwa1S8YbaIyOyxsvx6EJZpJZIpVJpEbp1t0tvtjudNDdHp5Xt0PsEfqMgeD-gVIEIJHI8FVonVTFY7CfBi42P1FH4jpMSRF2JPYNwQMwTFPfhNEA5lPHEYwj0sFxxAocw-xg6gvDcUMwgiaJYnibAshyccMmI2NcmCAoin1VManqRpmiQVp0HKPMGMLIJNgxMt9UOY4zkua4LUbJ50BeN5qw+L46x+Cd4ABYFQTscFISHOEETHLtURAeJp0xH9cXnYDzRXSlqRRS14AgqCYNVQR4MQrktEEFC0NQ6DvGwkNb3vZVP14V9NQ-VUgt1H8QGQ61RBNIlzVpLRHV0URrBMTQaE8ERBEEI9nE0U8RGoGwfCZQRcPDUACOjCjSORWr6CTWiQFKCoqgYjNmNY2ZszqLj1h40tQJAATKyE2t610psJJbaS21kmB5L+RSexUtT9ShOoYRHRE9J04B7n0jFZ3gYyCQeeLl3JCz12szRktSih0syoRhByvLRAK4xhGKn7AMMG9aEVB9HEc4L31B9s9RAEx+GoAxhDipdQOskw-10WGnrR4VA2ECg8r0UxRDQihBFQkwrAocQKvwqMiKSONyIZqiaJKMpcziElGmUYYYDqBR0H64teOG0aQCrGsRMnB5xMk1t2zFOSdKU3sQH7dStuHLTGasw70RnIy5QXC7kdJa61yskA6TRvRMZMbHfFx-GXPgZKiZJsmnsp6m-KVR8KHtcGtXgAPwuhsxxGEf8kZAi0rYQABaV0Mcc+yKdMa0dW5cw-F0Uw3J8TQEIykwaYjar6ZInWGpZ5M6Pa9MmJadpuj6IZRkmDo2nQABHYFUiFwaEv4itxfGqWptl2bThkjslYUlW1oHTbtu1vaFIOqdjsNkyTdj8yLcS+Ak94FOvPEdPvAkTQjxzyD89EQvi6ewHgYC1Ub4YN9g4-78eAkMK1AY7D2srwbwuh7RiFtKYKOVgjzFXELoKmGVfT8DEGTYQZcqp0wTNXZmTU2ZtTTIxJozd0Ddz7lgYgg8SzDxGqPCWwk6yiRkFPKSM95pz0WsrVafZVLLw0jtbSG89YGROmdY2pp97m0skfMB1AIG8CgbwGBQhwrcgQUgiwNBzxoNEBg1+d4-YqlJkHUKpiIr-zQsIYQmhgF8Wso6b0PomRowEMXeBaEIHOFJoBNCBcRRBDDLTQiuD15MyrrXZq9FG6kJYhkA4dQoDBFQJEWI1DVjcVoXxehglqxMMmpvGWzZ2Gz0VtwhevC1b8I1qvUcOtpZHQNnOc6UizIyNuvHV2-5TwuIkG4p0AZPGn3usTUwqEVGPxFL7EGT5iZmJVPMyx+oRC8CwhQexKMumP1PnaSOlhfAwLgS7cw4CA7CBMLYlR8EbFYKiSmBuJC8hJJSWk1InRegDBGOMKYwiImUUYRNFhxSZqlM4eUpaKJF58PWoOTWml6l6X1oZFpkjLrKAPrIsCrtk57NsUTI56jHAXwUecy59pHJOlubJCUUoZSnSNjM9+sMFlPhZcskAaEvBvU2XHOk+jIL2h9HuT6CEVG31MLba0YhVSAUuRcu5BD67EIzM85JqT0nsTiJxTJ4SwmAonkU6acs5oK07JU5SMKBHwqEVvZpDLd6K1pdKVFpkrqrixY40wijhVOlFa6XKJzJUY2lQAuVNjS7+ByFiWoFFQDqw2oCVIUAAC2awU1PFODmMIdQPwgCgOCFQ9AM11CzXUDoLEeCyClOwLgLx6jBCGkgAA6sYp87YyKW1SEkrNrbZm8HuNDGN6AE4qLxp9H6WFTBjigICLaA4-wASAmrJ4tQ80APEGstYOa10AAkyE8F4DOudkR0D7viQOI9QS8IRiVbqMAAACFNHFagPoIJgB9wQH1bEoakNYGRpQBTDpgDoGxFAuodfKO1KLIO9njTUxNya03Fszdmp4eaC0SXTah8tlb9TVpeGsGtDam19vfh2-ae0e3oDI4+Adf99TDtHaqRdzIybQWPfOngi6vDLp3egPN0VnDbtXQJ89rFD2cdPeJ5afAizBNvdROu96n0vvQG+j9VRP1zAWHUB9xAoCfofdILYAA3JQSbv2937rW3IElmBAa4CBsDdLUWiO3m5oG1TYWRCTQZ5DIAS1lp+OhngmGi2BZwxWyKBHbPEZOKRtt4gKMbyo1AXtbb6McqY26A5HJI6IxSLOrjv5-y8ZE3UNdVilG2Iq3ug9+or16WK9Jhrcnr2VXufqAgj7n3atfe+ozarXnpP-fZxzupnPEggxI9z9rZteYTVEPzqbsOlrQ7msLha1tlui1WqANaiP1oS+aWjKoUvLVAN29LNHMuDsikx2GQpUqCD-EIKTA4nsIzqwJ7jZXAI-eIDJy9H3geSY6xEO9ABhPEEAH1Jrpfp0gWwUnGagJSfTsRTi6DG4BujTnQPTfpQtpFYid5Qfgz5lbAWgsbYw9tlD63cORXC0dzEJ2SRnfbQ0iM12Mv9vuzwJjCFHSvWtPnD7-9VSbqAX2UTeaI5R1inLyrYm2tNYpCes96v5M3tAND2HD7MDgihGAAgkQH1gEBEgJtluoB6Z-TZh9iw8jQEiKcWg+m1Ce4E5EXVAGHP48m4T8DxPGXQfEeHyny9qc7bp1trDjPdt4fzQz3Ux3G2naSxdrtAIbtc6y0O1AtQE6eQsCIJXxVJf6kV9HFXVXGuGieoDsHjXQc64h4p1m+oeq6aR+poi+YkAPryI204b7H1IHQFiWcjVxtB-fSH1zsG5swYW9HyEsek-x-1Kz7fzOE8Rfi5nzn2eedXbz-zoDgvGPF5HelC+MCi5R2NEVrXPAhPK5XarvNAgRASBbw72ay11b3a3WAU31yU2ahhwgDh2N22B63N0t2t1tzAHtys1-WIGd1dygHd092IG9wfV9393n0cAJxcxm3D1Jw8xX0WwQ2WyQzjzqBC0213zT1pwPzYMT3T3ZxP2UC52S3PzSyvzo0OhawHGJhqzsTf3nVAL43lx4FWXWUAIvXB2yzvwTnSivgmT-Fq3oCqAIAzTXyNk7wvwUhwGEPQHgAAGI8heA7C8hEYchF8KCw9d4DdYCjcTdECLcrcbdzQ7cHdrMqFsC3cPcvcfdiA-cH0QBV9I95xbwltfNGD98WD6duCOC9suCj8M9EtZlBC9UIg+dbsBcZDT1FDhA1k3B29VD9R5Cf9uMBBLlBAVCJM28GMQAmNXt4YqBrQVEAw1gDCjD4jzoQg9dCishLCbCHD7CnDyCidXUusQArNhsNVUh+9VN+t1Mes30sDBsyB1Mzc6h1jFBn0jdp9EcFAcc4ifxF4chzN0AYBZBWC7oekbAjQBAxAldTB4FT5PBJlHRqBKj+A1lA0AAvdHNNNsJBCme6IMQMXwaCWVTBUUAgGoE4FNdiMIC4CAgabJUWUeMAJJF4SoYgdnCIRQYgWTCYcQCYB9LVTABiB9CYJ4eQF1VE7JUzMJSIVNZ9F4GuCuBMQdEDNQZ44gFkqfCAAAeW2xWmBHoGYGgFHwgFA1qEGAQ1AFQEBDxEWIgClHQHVNhVXG4HoGHUqCZ0NIHD3yiEpHtx4FsPsNmNiIVKVLxB2ktIpPoNoSqEVIRV2h5OgDqHtM8BDP4DWFH3d2YCSWt1QCh1tKDP1GsLAGTJTPDPtwwDqDjMDODNDLDPoDyHTPqEGFIHN1OCnziB4GNOxCcxxMwEYHJxBH8CAA
```

Some observations:

- REQUEST_TYPE is the name for the request, such as ```Info```, ```RequestNodes``` and others.
- Manager::handleAnswer always fills a std::promise with the answer. A thread that called a request within the manager towards another node will wait for a few seconds or until the answer is received. 